<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>力扣315-计算右边小于当前数的个数</title>
      <link href="/2022/05/28/%E5%8A%9B%E6%89%A3315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E8%BE%B9%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2022/05/28/%E5%8A%9B%E6%89%A3315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E8%BE%B9%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><font size=4> 给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量 </font><font size=4>思路很简单，这里实际上寻找的就是一个逆序对的问题，所以有很多的解法： </font><ul><li><font size=4>树状数组</font></li><li><font size=4>归并排序</font></li><li><font size=4>权值线段树</font></li></ul><font size=4>实际上，我用树状数组，把原来的数组逆序过后，不就变成了正序的问题？然后看一下数据范围，果然有负数，还挺大的，那么离散化一下不就完了吗？</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edge &amp;rhs) <span class="type">const</span>  &#123;</span><br><span class="line">            <span class="keyword">if</span>(rhs.x==x) <span class="keyword">return</span> y&lt;rhs.y;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> x&lt;rhs.x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x&amp;(-x); &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;edge&gt; <span class="title">p</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i].x=nums[i<span class="number">-1</span>],p[i].y=i;</span><br><span class="line">        <span class="built_in">sort</span>(p.<span class="built_in">begin</span>()+<span class="number">1</span>,p.<span class="built_in">begin</span>()+n+<span class="number">1</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tree</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rank</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rank[p[i].y]=i;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; add=[&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=n) &#123; tree[i]+=<span class="number">1</span>; i+=<span class="built_in">lowbit</span>(i); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; getSum=[&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">                sum+=tree[i];</span><br><span class="line">                i-=<span class="built_in">lowbit</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">reverse</span>(rank.<span class="built_in">begin</span>()+<span class="number">1</span>,rank.<span class="built_in">begin</span>()+<span class="number">1</span>+n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">add</span>(rank[i]);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;rank[i]&lt;&lt;&#x27; &#x27;&lt;&lt;getSum(rank[i]-1)&lt;&lt;endl;</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">getSum</span>(rank[i]<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>信号量解决同步互斥问题</title>
      <link href="/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/26/%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="同步互斥问题的产生"><a href="#同步互斥问题的产生" class="headerlink" title="同步互斥问题的产生"></a>同步互斥问题的产生</h2><font size=4>实际上我是从教材《现代操作系统》中了解到这种类型的问题，也叫做$IPC$问题，有几个很著名的问题，还蛮有意思的，就特意写篇笔记记录一下 。==其中我只关注信号量解决问题的逻辑。而不是具体的实现。==</font><hr><h3 id="一些概念的理解："><a href="#一些概念的理解：" class="headerlink" title="一些概念的理解："></a>一些概念的理解：</h3><ul><li><font size=4 color="red"> 临界区域：就是两个进程之间共享的数据区域，进程都可以对其进行读写。</font></li><li><font size=4 color="red">信号量：**实际上就是一个计数器**，表示的是一种权限资源。</font></li><li><font size=4> $P(s)$：如果$s>0$，那么$P$就会把$s$减$1$，如果$s=0$那么这个进程就会被挂起，执行其他的进程。</font></li><li><font size=4> $V(s)$：$V$会把$s$加$1$。</font></li></ul><font size=4> **注意这里对信号量$s$的的操作$P(s),V(s)$都具有原子性。** </font><hr><h3 id="信号量的理解："><a href="#信号量的理解：" class="headerlink" title="信号量的理解："></a>信号量的理解：</h3><font size=4>信号量的数值就是相当于可以访问共享数据区域的最大进程数，==如果信号量为二元信号量$binary \ semaphore$，那么和互斥锁是一样的作用，通常用于严格限制的区域。如果信号量不是二元的，那么一般是用于对有限数量实例组成的资源的访问。==</font><font size=4>下面是我从一个视频看到的，挺有意思的。</font><font size=4>**互斥锁（二元信号量）** 就像一把钥匙。谁拿到它就可以上厕所，但是只有一个人才能上厕所。所有人都是一个一个地去上厕所。</font><p><img src="https://img-blog.csdnimg.cn/daa8079734c44c0c8b21806171853176.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/31dbf38673614ad6b0bd52297c4d2bba.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2f327fd8878e4d1b9f5904d70d215a91.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>类似于文件的访问，**只有一把钥匙，谁拿到那么谁就可以获取。**</font><p><img src="https://img-blog.csdnimg.cn/afa75f5a584b4bb08de9511bcd05f8ad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>**多元信号量** 就像多把钥匙。谁拿到它就可以上厕所，允许多个人同时上厕所。</font><p><img src="https://img-blog.csdnimg.cn/b978e2c1039d4a53b9eb8b84063c63ba.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/890dee85c9df446c83d49eda0998acfc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/c562b1fff9bc4928b77e7249b0059c9e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b04c4bc9400c4bed87fb141062479567.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>类似于文件的访问，**有多把钥匙，谁拿到那么谁就可以获取文件资源。** 最常见的应用就是利用信号量控制多线程的并发数量，假设我的设备支持最高$1000$的线程并发，但是我设置信号量为$10$，那么实际上最多并发运行的线程不会超过$10$个。</font><hr><h3 id="使用信号量解决问题"><a href="#使用信号量解决问题" class="headerlink" title="使用信号量解决问题"></a>使用信号量解决问题</h3><h4 id="一、生产者和消费者问题"><a href="#一、生产者和消费者问题" class="headerlink" title="一、生产者和消费者问题"></a>一、生产者和消费者问题</h4><p><img src="https://img-blog.csdnimg.cn/d76f4c95e81e476f80b0194f3e3dbe17.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>消费者进程和生产者进程存在一个共享的数据区域。所以存在==互斥==的问题。所以使用二元信号量来严格限制两个进程的读写。 </font><font size=4 color="green">生产者：</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">  P(&amp;mutex); <span class="comment">// 申请钥匙</span></span><br><span class="line">  createItem(); <span class="comment">// 生产数据</span></span><br><span class="line">  V(&amp;mutex) <span class="comment">// 归还钥匙</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4 color="red">消费者：</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">  P(&amp;mutex); <span class="comment">// 申请钥匙</span></span><br><span class="line">  consumeItem(); <span class="comment">// 消耗数据</span></span><br><span class="line">  V(&amp;mutex) <span class="comment">// 归还钥匙</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>**消费者消费所有的数据之后，不能继续消费数据，所以这个时候要唤醒生产者，同理，当槽满了的时候， 不能继续生产数据，所以这个时候要唤醒消费者，所以存在==同步==的问题。同步的问题往往可以使用==拓扑图==的模式直观解决。**</font><p><img src="https://img-blog.csdnimg.cn/595c4f22a8f3416cb6e07ed3a6768256.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4 color="green">生产者：</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">P(&amp;slot); <span class="comment">// 查看是否还有空的槽，没有的话就停止阻塞</span></span><br><span class="line">P(&amp;mutex);</span><br><span class="line">createItem();</span><br><span class="line">V(&amp;mutex);</span><br><span class="line">V(&amp;items); <span class="comment">// 把数据的数量增加一</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4 color="red">消费者：</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">P(&amp;item); <span class="comment">// 查看是否还有数据，，没有的话就阻塞</span></span><br><span class="line">P(&amp;mutex);</span><br><span class="line">consumeItem();</span><br><span class="line">V(&amp;mutex);</span><br><span class="line">V(&amp;slot); <span class="comment">// 把空的槽的槽的数量加一</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><font size=6> $\color{Blue}{Code}$ </font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *buf; <span class="comment">// 缓存区的大小</span></span><br><span class="line">    <span class="type">int</span> n; <span class="comment">// 最大的item数量</span></span><br><span class="line">    <span class="type">int</span> front; <span class="comment">// 第一个item</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">// 最后一个item</span></span><br><span class="line">    <span class="type">sem_t</span> mutex; <span class="comment">// 锁变量</span></span><br><span class="line">    <span class="type">sem_t</span> slots; <span class="comment">// 空的槽数</span></span><br><span class="line">    <span class="type">sem_t</span> items; <span class="comment">// item的数量</span></span><br><span class="line">&#125; <span class="type">sbuf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbuf_insert</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">sbuf_t</span>* sp = (<span class="type">sbuf_t</span>*) arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start produce\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;sp-&gt;slots);</span><br><span class="line">        sem_wait(&amp;sp-&gt;mutex);</span><br><span class="line">        sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Insert successfully!\n&quot;</span>);</span><br><span class="line">        sem_post(&amp;sp-&gt;mutex);</span><br><span class="line">        sem_post(&amp;sp-&gt;items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbuf_remove</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">sbuf_t</span>* sp = (<span class="type">sbuf_t</span>*) arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start consume\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> item;</span><br><span class="line">        sem_wait(&amp;sp-&gt;items);</span><br><span class="line">        sem_wait(&amp;sp-&gt;mutex);</span><br><span class="line">        item = sp-&gt;buf[(++sp-&gt;front) % (sp-&gt;n)];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, item);</span><br><span class="line">        sem_post(&amp;sp-&gt;mutex);</span><br><span class="line">        sem_post(&amp;sp-&gt;slots);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> pro, con;</span><br><span class="line">    <span class="type">sbuf_t</span> temp;</span><br><span class="line">    temp.buf = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    temp.n = <span class="number">2</span>;</span><br><span class="line">    temp.front = temp.rear = <span class="number">0</span>;</span><br><span class="line">    sem_init(&amp;temp.mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;temp.slots, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    sem_init(&amp;temp.items, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">sbuf_t</span>* S = &amp;temp;</span><br><span class="line">    pthread_create(&amp;pro, <span class="number">0</span>, sbuf_insert, (<span class="type">void</span>*)S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread producer is done!\n&quot;</span>);</span><br><span class="line">    pthread_create(&amp;con, <span class="number">0</span>, sbuf_remove, (<span class="type">void</span>*)S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread consumer is done!\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、竞争有限资源类型问题（哲学家就餐问题和生产者-消费者问题）"><a href="#二、竞争有限资源类型问题（哲学家就餐问题和生产者-消费者问题）" class="headerlink" title="二、竞争有限资源类型问题（哲学家就餐问题和生产者-消费者问题）"></a>二、竞争有限资源类型问题（哲学家就餐问题和生产者-消费者问题）</h4><h5 id="哲学家就餐问题：（五个哲学家一直在思考吃饭，吃饭的时候必须要两个叉子。思考的时候会把叉子全部放下去。）"><a href="#哲学家就餐问题：（五个哲学家一直在思考吃饭，吃饭的时候必须要两个叉子。思考的时候会把叉子全部放下去。）" class="headerlink" title="哲学家就餐问题：（五个哲学家一直在思考吃饭，吃饭的时候必须要两个叉子。思考的时候会把叉子全部放下去。）"></a>哲学家就餐问题：（五个哲学家一直在思考吃饭，吃饭的时候必须要两个叉子。思考的时候会把叉子全部放下去。）</h5><p><img src="https://img-blog.csdnimg.cn/2a457bee58a94fe19b54e666e8a60664.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>这里使用创建五个线程表示五个哲学家：（**因为一个哲学家本质就是一个同时的生产者和消费者，所以把生产者函数与消费者函数放在一起，叉子就是数据项**）</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> id)</span> &#123; <span class="comment">// id表示是哪位哲学家</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">think();</span><br><span class="line">take_forks(); </span><br><span class="line">eat();</span><br><span class="line">put_forks();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>其中我们关心的只有拿叉子和放叉子的过程，因为一把叉子不可能同时拿起来和放下去所以存在==互斥==的问题。（**本质就是生产者和消费者的问题**）</font><font size=4 color="green">拿叉子：</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">take_forks</span><span class="params">(<span class="type">int</span> id)</span> &#123; <span class="comment">// id表示的哲学家的位置</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">P(&amp;mutex);</span><br><span class="line">getforks();</span><br><span class="line">V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4 color="red">放叉子：</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">put_forks</span><span class="params">(<span class="type">int</span> id)</span> &#123; <span class="comment">// id表示的哲学家的位置</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">P(&amp;mutex);</span><br><span class="line">backforks();</span><br><span class="line">V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>叉子必须要有的时候才可以拿，同理位置必须是空的时候才可以放。但是这里的位置容量为$1$，所以不用判断是否什么时候可以放，这是一个==同步==的问题。注意这里的代码的$ID$我使用了数字来表示哲学家和筷子的位置，总共为$10$。</font><font size=4 color="green">拿叉子：</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">take_forks</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">P(&amp;s[(id+<span class="number">1</span>)%<span class="number">10</span>]); <span class="comment">// 判断相邻的哲学家有没有筷子，没有就等待别人吃完</span></span><br><span class="line">P(&amp;s[(id<span class="number">-1</span>+<span class="number">10</span>)%<span class="number">10</span>]);</span><br><span class="line">P(&amp;mutex);</span><br><span class="line">getforks();</span><br><span class="line">V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><font size=4 color="red">放叉子：</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">put_forks</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">P(&amp;mutex);</span><br><span class="line">backforks();</span><br><span class="line">V(&amp;mutex);</span><br><span class="line">V(&amp;s[(id+<span class="number">1</span>)%<span class="number">10</span>]); <span class="comment">// 放下筷子</span></span><br><span class="line">V(&amp;s[(id<span class="number">-1</span>+<span class="number">10</span>)%<span class="number">10</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>教材的解法使用了状态表示，这样就可以免去$ID$的编码。其实很多的有限资源竞争的问题本质就是生产者-消费者模型的拓展。下面的代码也使用了标准的解法：</font><font size=6> $\color{Blue}{Code}$ </font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT ((id + 5 - 1) % 5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT ((id + 1) % 5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATING 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"><span class="type">sem_t</span> phi[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> state[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">take_forks</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">put_forks</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Philosopher</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *temp = (<span class="type">int</span> *)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is thinking.\n&quot;</span>, *temp);</span><br><span class="line">        take_forks(*temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is eating.\n&quot;</span>, *temp);</span><br><span class="line">        put_forks(*temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">take_forks</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    state[id] = HUNGRY;</span><br><span class="line">    test(id);</span><br><span class="line">    sem_post(&amp;mutex);</span><br><span class="line">    sem_wait(&amp;phi[id]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d get the forks.\n&quot;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">put_forks</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    state[id] = THINKING;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d puts the forks\n&quot;</span>, id);</span><br><span class="line">    test(LEFT);</span><br><span class="line">    test(RIGHT);</span><br><span class="line">    sem_post(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(state[id] == HUNGRY &amp;&amp; state[LEFT] != EAGAIN &amp;&amp; state[RIGHT] != EAGAIN) &#123;</span><br><span class="line">        state[id] = EATING;</span><br><span class="line">        sem_post(&amp;phi[id]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread[<span class="number">5</span>];</span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) sem_init(&amp;phi[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;thread[i], <span class="number">0</span>, Philosopher, (<span class="type">void</span>*)(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、竞争互斥问题。（读者写者问题，过桥问题，浴室问题）"><a href="#三、竞争互斥问题。（读者写者问题，过桥问题，浴室问题）" class="headerlink" title="三、竞争互斥问题。（读者写者问题，过桥问题，浴室问题）"></a>三、竞争互斥问题。（读者写者问题，过桥问题，浴室问题）</h4><h5 id="读者写者问题：（读的进程和写的进程之间的同步互斥问题，我觉得和生产者-消费者模型是很大不一样的，-这里有了优先级的说法，所以这里的问题也有两个变种：读者优先级大于写者，或者是写者的优先级大于读者。并且这里是没有数据数量限制的，数据也是可以修改的。-）"><a href="#读者写者问题：（读的进程和写的进程之间的同步互斥问题，我觉得和生产者-消费者模型是很大不一样的，-这里有了优先级的说法，所以这里的问题也有两个变种：读者优先级大于写者，或者是写者的优先级大于读者。并且这里是没有数据数量限制的，数据也是可以修改的。-）" class="headerlink" title="读者写者问题：（读的进程和写的进程之间的同步互斥问题，我觉得和生产者-消费者模型是很大不一样的，==这里有了优先级的说法，所以这里的问题也有两个变种：读者优先级大于写者，或者是写者的优先级大于读者。并且这里是没有数据数量限制的，数据也是可以修改的。==）"></a>读者写者问题：（读的进程和写的进程之间的同步互斥问题，我觉得和生产者-消费者模型是很大不一样的，==这里有了优先级的说法，所以这里的问题也有两个变种：读者优先级大于写者，或者是写者的优先级大于读者。并且这里是没有数据数量限制的，数据也是可以修改的。==）</h5><font size=4>这里假设读者的优先级大于写者。其实这里还有一个细节的问题，那就是所有的相同类型的进程不应该一个一个进去，所有的读进程应该可以同时进去，而写操作则不一定。</font><font size=4 color="green">读者：</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">P(&amp;mutex);</span><br><span class="line">read();</span><br><span class="line">V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4 color="red">写者：</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">P(&amp;mutex);</span><br><span class="line">write();</span><br><span class="line">V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>但是这里的读者并不止有一个，所以为了保证读操作优先级更高，我们规定写者只能一个一个进来，读者只要是"读"模式就可以进来，只有读完了，才能写。==使用拓扑的表达就是下面这样==：</font><p><img src="https://img-blog.csdnimg.cn/223e28c696a44b6596b2c6f7ebc3c239.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4 color="green">读者：</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reader_in</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">P(&amp;mutex);</span><br><span class="line">readcnt++; <span class="comment">// 通过readcnt可以实现读者不用一个一个进来，而是用一个数字表达所有等待的读者进程</span></span><br><span class="line"><span class="keyword">if</span>(readcnt == <span class="number">1</span>) P(&amp;w); <span class="comment">// 有读者进程，获得权限</span></span><br><span class="line">V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader_out</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">P(&amp;mutex);</span><br><span class="line">readcnt--;</span><br><span class="line"><span class="keyword">if</span>(readcnt == <span class="number">0</span>) V(&amp;w); <span class="comment">// 读者没了，激活写者</span></span><br><span class="line">V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><font size=4 color="red">写者：</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">P(&amp;w) <span class="comment">// 等待写入</span></span><br><span class="line">...</span><br><span class="line">write();</span><br><span class="line">...</span><br><span class="line">v(&amp;w)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>这里可以观察到信号量$w$保证了读者和写者的互斥，信号量$mutex$保证了共享数据$readcnt$的正确性。（==由于使用了无限循环，也就是有无数个读者，会产生饥饿现象。==）</font><font size=6> $\color{Blue}{Code}$ </font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"><span class="type">sem_t</span> w;</span><br><span class="line"><span class="type">int</span> readcnt;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader_in</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader_out</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">reader</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *temp = (<span class="type">int</span> *)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        reader_in(*temp);</span><br><span class="line">        reader_out(*temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader_in</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        readcnt++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A reader in.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(readcnt == <span class="number">1</span>) sem_wait(&amp;w);</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader_out</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        readcnt--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A reader out.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(readcnt == <span class="number">0</span>) sem_post(&amp;w);</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> * temp = (<span class="type">int</span> *) arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        sem_wait(&amp;w);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SUCCESS write data %d\n&quot;</span>, *temp);</span><br><span class="line">        sem_post(&amp;w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> r_thread[<span class="number">10</span>];</span><br><span class="line">    <span class="type">pthread_t</span> w_thread[<span class="number">2</span>];</span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;w, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">12</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) pthread_create(&amp;r_thread[i], <span class="number">0</span>, reader, (<span class="type">void</span>*)(p+i));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) pthread_create(&amp;w_thread[i], <span class="number">0</span>, writer, (<span class="type">void</span>*)(p+i+<span class="number">10</span>));</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他的问题都可以通过这三个模型推导得到，因此掌握这三个基本模型十分重要。文章写作不易，转载标明出处。"><a href="#其他的问题都可以通过这三个模型推导得到，因此掌握这三个基本模型十分重要。文章写作不易，转载标明出处。" class="headerlink" title="==其他的问题都可以通过这三个模型推导得到，因此掌握这三个基本模型十分重要。文章写作不易，转载标明出处。=="></a>==其他的问题都可以通过这三个模型推导得到，因此掌握这三个基本模型十分重要。文章写作不易，转载标明出处。==</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二进制算法刷题模板</title>
      <link href="/2022/05/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/05/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="二进制的位操作"><a href="#二进制的位操作" class="headerlink" title="二进制的位操作"></a>二进制的位操作</h2><p><img src="https://img-blog.csdnimg.cn/a93b9402f2284e45a0ebf3548f44f6af.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><hr><h2 id="常用的二进制内置函数"><a href="#常用的二进制内置函数" class="headerlink" title="常用的二进制内置函数"></a>常用的二进制内置函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __builtin_ctz(<span class="type">unsigned</span> <span class="type">int</span> x);</span><br><span class="line"><span class="type">int</span> __builtin_ctzll(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x);</span><br><span class="line"><span class="comment">// 返回 x 二进制表示下最低位的1后面有多少个0</span></span><br><span class="line"><span class="type">int</span> __builtin_popcount(<span class="type">unsigned</span> <span class="type">int</span> x);</span><br><span class="line"><span class="type">int</span> __builtin_popcountll(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x);</span><br><span class="line"><span class="comment">// 返回 x 二进制表示下有多少个1</span></span><br></pre></td></tr></table></figure><hr><h2 id="成对变换"><a href="#成对变换" class="headerlink" title="成对变换"></a>成对变换</h2><p>对于非负整数$n$而言：</p><ul><li>$n=2k$时，$n \ xor 1$等于$n+1$</li><li>$n=2k+1$时，$n \ xor 1$等于$n-1$</li></ul><hr><h2 id="lowbit-运算"><a href="#lowbit-运算" class="headerlink" title="$lowbit$运算"></a>$lowbit$运算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; (-x);&#125; <span class="comment">// 返回最低位的1及其后边所有的0</span></span><br></pre></td></tr></table></figure><p>比如，$n=10=(1010)_2, \ lowbit(n)=(10)_2=2$</p><p>技巧使用：搭配树状数组，搭配$Hash$找到整数$x$在二进制表示下所有的1的位（下面为解决代码）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> H[<span class="number">37</span>], x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">36</span>; i++) &#123;H[(<span class="number">1ll</span> &lt;&lt; i) % <span class="number">37</span>] = i;&#125;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; x) &#123;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; H[<span class="built_in">lowbit</span>(x) % <span class="number">37</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找，二分答案模板</title>
      <link href="/2022/05/26/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/05/26/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>在单调递增的序列$a$中查找$\ge x$的数中最小的一个，也就是$x$的后继。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; r) &#123; </span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &gt;= x) &#123;</span><br><span class="line">r = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在单调递增的序列$a$中查找$\le x$的数中最大的一个，也就是$x$的前驱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &lt;= x) &#123;</span><br><span class="line">l = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$\color{Red} STL$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x); <span class="comment">// 返回指向x的后继的迭代器</span></span><br><span class="line">s.<span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x); <span class="comment">// 返回指向&gt;x的最小的一个元素的迭代器</span></span><br></pre></td></tr></table></figure><hr><h2 id="实数域上的二分"><a href="#实数域上的二分" class="headerlink" title="实数域上的二分"></a>实数域上的二分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l + eps &lt; r) &#123; <span class="comment">// eps是误差，通常为很小的常数</span></span><br><span class="line"><span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cal</span>(mid)) &#123;</span><br><span class="line">r = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接循环固定次数好了:</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cal</span>(mid)) &#123;</span><br><span class="line">r = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><p>查找最大的满足值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">valid</span>(mid)) &#123;</span><br><span class="line">l = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>查找最小的满足值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">valid</span>(mid)) &#123;</span><br><span class="line">r = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  二分答案最强的模板</span></span><br><span class="line"><span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>三分求单峰函数极值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">fabs</span>(r - l) &gt;= eps) &#123;</span><br><span class="line"><span class="type">double</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cal</span>(mid + eps) &gt; <span class="built_in">cal</span>(mid - eps)) &#123;</span><br><span class="line">l = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>快速幂，龟速乘，光速乘模板</title>
      <link href="/2022/05/26/%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%8C%E9%BE%9F%E9%80%9F%E4%B9%98%EF%BC%8C%E5%85%89%E9%80%9F%E4%B9%98%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/05/26/%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%8C%E9%BE%9F%E9%80%9F%E4%B9%98%EF%BC%8C%E5%85%89%E9%80%9F%E4%B9%98%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>求$a^b mod p (1 \le a, b, p \le 10^{18})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">quick_power</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123; <span class="comment">// ll 是long long类型</span></span><br><span class="line">    ll ans = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">for</span>(; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="龟速乘（解法一）"><a href="#龟速乘（解法一）" class="headerlink" title="龟速乘（解法一）"></a>龟速乘（解法一）</h2><p>求$a*b \ mod p (1 \le a, b, p \le 10^{18})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">quick_mul</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123; <span class="comment">// ll 是long long类型</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = (ans + a) % p;</span><br><span class="line">        a = a * <span class="number">2</span> % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="光速乘（解法二）"><a href="#光速乘（解法二）" class="headerlink" title="光速乘（解法二）"></a>光速乘（解法二）</h2><p>求$a*b \ mod p (1 \le a, b, p \le 10^{18})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ull <span class="title">mul</span><span class="params">(ull a, ull b, ull p)</span> </span>&#123; <span class="comment">// ull 是 unsigned long long 类型，ll 是long long类型</span></span><br><span class="line">    a %= p, b %= p;</span><br><span class="line">    ull c = (<span class="type">long</span> <span class="type">double</span>)a * b / p;</span><br><span class="line">    ull x = a * b, y = c * p;</span><br><span class="line">    ll ans = (<span class="type">long</span> <span class="type">long</span>)(x % p) - (<span class="type">long</span> <span class="type">long</span>)(y % p);</span><br><span class="line">    <span class="keyword">if</span>(ans &lt; <span class="number">0</span>) ans += p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>平面分割，空间分割各种变形问题</title>
      <link href="/2022/05/26/%E5%B9%B3%E9%9D%A2%E5%88%86%E5%89%B2%EF%BC%8C%E7%A9%BA%E9%97%B4%E5%88%86%E5%89%B2%E5%90%84%E7%A7%8D%E5%8F%98%E5%BD%A2%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/26/%E5%B9%B3%E9%9D%A2%E5%88%86%E5%89%B2%EF%BC%8C%E7%A9%BA%E9%97%B4%E5%88%86%E5%89%B2%E5%90%84%E7%A7%8D%E5%8F%98%E5%BD%A2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、直线分割的变形问题"><a href="#一、直线分割的变形问题" class="headerlink" title="一、直线分割的变形问题"></a>一、直线分割的变形问题</h2><h3 id="1、直线分割的区域分为有界和无界的区域，那么-n-条直线最多将平面分为多少个有界的区域？"><a href="#1、直线分割的区域分为有界和无界的区域，那么-n-条直线最多将平面分为多少个有界的区域？" class="headerlink" title="1、直线分割的区域分为有界和无界的区域，那么$n$条直线最多将平面分为多少个有界的区域？"></a>1、直线分割的区域分为有界和无界的区域，那么$n$条直线最多将平面分为多少个有界的区域？</h3><font size=4>==解决分割问题的一个很有用的思想为就是动态分析，观察总结。== 那么我们可以假设第$n$条直线交于$k>0$个不同的点，那么观察就可以得到一个结论，那就是我们可以得到新的$k-1$个有界的区域和$2$个无界的区域。因此，最多的有界区域与最多区域解$L_n$的差为$2*n$，所有可以得到：</font><script type="math/tex; mode=display">T_n=S_{n-2}=L_n-2*n=\dfrac{(n-1)(n-2)}{2}=\sum_{i=1}^{n-2}i</script><font size=4>其中的$S_n$是三角形数，$S_n=\dfrac{n(n+1)}{2}$。下图中，蓝色线为第$4$条线，生成$2$个红色的有界区域和$2$个黄色的无界区域。</font><p><img src="https://img-blog.csdnimg.cn/9ecadaf5cf3142f6af919fb76bbf9a63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><hr><h3 id="2、折线分割问题，这次不是直线去分割平面了，是折线，那么-n-条折线最多可以将平面分割为多少个区域呢？"><a href="#2、折线分割问题，这次不是直线去分割平面了，是折线，那么-n-条折线最多可以将平面分割为多少个区域呢？" class="headerlink" title="2、折线分割问题，这次不是直线去分割平面了，是折线，那么$n$条折线最多可以将平面分割为多少个区域呢？"></a>2、折线分割问题，这次不是直线去分割平面了，是折线，那么$n$条折线最多可以将平面分割为多少个区域呢？</h3><font size=4>动态分析：如何才能最多的分割平面？==就是产生尽量多的交点==。观察总结：对于折线来说，加入一条折线后，区域的增加个数相当于两条直线加入分割后减少少了$2$个区域。什么意思呢？当$n=1$的时候，区域数为$2$，若是两条直线相交那么可以产生的区域数为$4$，原因就是折线的形状不能将左边那个大的蓝色$2$区域分割。同样的，每加入一条折线都会少两个区域，所以可以得到：</font><p><img src="https://img-blog.csdnimg.cn/dfcf55f827ca477bb443fd6c3601aff7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/bf700e8d43fa42b8887977c230cc37c3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><script type="math/tex; mode=display">T_n=L_{2n}-2n=2n^2-n+1</script><font size=4>$L_n$就是经典$n$条直线分割最多平面问题的解，满足$L_n=1+S_n=1+\dfrac{n(n+1)}{2}$。</font><font size=4>**==其实有一个经验总结，就是区域增加的个数和交点的个数总是密切相关的，并且所有的区域的个数和直线的条数，交点数也是息息相关。这对于那些要求平行线的交点分割的变形题目非常有帮助。具体关系就是：==**</font><font size=4>经验$1$ **==区域增加的个数=新产生的交点个数+1==**</font><font size=4>经验$2$ **==区域的个数=1+线的条数+交点的个数（这里如果是$n$线汇合一点，那么交点个数计算为$n-1$个，并且对于无穷延伸的线条来说，不论是直线好，还是折线也好，都算作一条线）==**</font><font size=4>那么回头再看看刚才的题目，很容易得到，对于第$n$条折线来说，一次最多可以新产生$4(n-1)$个交点，所以最多可以产生新的区域数$4(n-1)+1$，就是$4n-3$个，那么就可以得到递推式子：</font><script type="math/tex; mode=display">T_n=T_{n-1}+4n-3</script><font size=4>结果是一样的。同样我们可以采用思路$2$去解决，直接计算区域的总数：</font><script type="math/tex; mode=display">T_n=1+n+4*\sum_{i=1}^{n-1}i=2n^2-n+1</script><hr><h3 id="3、折线？换成”Z”型线条怎么计算？"><a href="#3、折线？换成”Z”型线条怎么计算？" class="headerlink" title="3、折线？换成”Z”型线条怎么计算？"></a>3、折线？换成”Z”型线条怎么计算？</h3><font size=4>我们可以只用充分长的线段的极狭窄的$Z$形线来构造最多的交点的情况，也就是当第$n$条线加入时，它与其余的$n-1$条线都有$9$个交点，那么我们根据经验$1$或者$2$来解决。</font><p><img src="https://img-blog.csdnimg.cn/1d11cbecef3d46fd88dc06d3f4a4433a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>**使用经验$1$的话**，那么我们就可以得到对于第$n$条线来说，最多可以产生$9(n-1)$个交点，那么产生的区域最多为$9(n-1)+1$，所以可以得到最优解为：</font><script type="math/tex; mode=display">T_n=T_{n-1}+9n-8</script><script type="math/tex; mode=display">T_n=\dfrac{9}{2}n^2-\dfrac{7}{2}n+1</script><font size=4>**使用经验$2$的话**，那么我们就可以得到对于第$n$条线来说，最多可以产生$9(n-1)$个交点，那么区域的最多的交点数为$$9\sum _{i=1}^{n-1}i$$**注意这里的$Z$形线都只是一条线**，所以可以得到最优解为：</font><script type="math/tex; mode=display">T_n=1+n+9\sum _{i=1}^{n-1}i</script><script type="math/tex; mode=display">T_n=\dfrac{9}{2}n^2-\dfrac{7}{2}n+1</script><font size=4>可见，两个方法殊途同归,本质都是一样的，经验$2$其实就是经验$1$的叠加形式。</font><hr><h2 id="二、封闭曲线分割平面的问题："><a href="#二、封闭曲线分割平面的问题：" class="headerlink" title="二、封闭曲线分割平面的问题："></a>二、封闭曲线分割平面的问题：</h2><font size=4>直接上干货，因为这个问题的水非常深，所以在这里直接使用经验而不是严谨的推理，如果对原理很有兴趣，就自己去看论文吧。~~有这个时间，不去玩玩，逛逛GitHub之类的~~</font><font size=4>经验总结：**==对于$k$个新的交点产生，会增加$k-1$个有界的区域，和$2$个无界的区域，这在直线分割平面的变形第一题就已经说过了。那么由于是封闭的曲线产生的区域，是有界限的，所以新产生的区域=新产生的交点产生的有界区域和。==**</font><h3 id="1、三角形分割问题"><a href="#1、三角形分割问题" class="headerlink" title="1、三角形分割问题:"></a>1、三角形分割问题:</h3><p><img src="https://img-blog.csdnimg.cn/512ff6eae8d844c3a6903bb8be42d860.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>对于三角形来说，对于第$n$个三角形，一次最多可以产生的新的交点数为$6(n-1)$，所以新的产生的区域数为$6(n-1)$</font><script type="math/tex; mode=display">T_n=T_{n-1}+6(n-1),T_1=2</script><script type="math/tex; mode=display">T_n=3n^2-3n+2</script><hr><h3 id="2、圆形分割问题："><a href="#2、圆形分割问题：" class="headerlink" title="2、圆形分割问题："></a>2、圆形分割问题：</h3><p><img src="https://img-blog.csdnimg.cn/c82317fd24d94942b4ced913aae467a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>对于圆来说，对于第$n$个圆，一次最多可以产生的新的交点数为$2(n-1)$，原因就是因为两个圆最多有两个交点，所以新的产生的区域数为$2(n-1)$</font><script type="math/tex; mode=display">T_n=T_{n-1}+2(n-1),T_1=2</script><script type="math/tex; mode=display">T_n=n^2-n+2</script><hr><h3 id="3、椭圆分割问题："><a href="#3、椭圆分割问题：" class="headerlink" title="3、椭圆分割问题："></a>3、椭圆分割问题：</h3><p><img src="https://img-blog.csdnimg.cn/ea65fb1478684ccbad3f0a4bc6182d7d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>对于椭圆来说，对于第$n$个椭圆，一次最多可以产生的新的交点数为$4(n-1)$，原因就是因为两个椭圆最多有四个交点，所以新的产生的区域数为$4(n-1)$</font><script type="math/tex; mode=display">T_n=T_{n-1}+4(n-1),T_1=2</script><script type="math/tex; mode=display">T_n=2n^2-2n+2</script><hr><font size=4>三角形，两个三角形最大交点数：$6$，$T_n=3n^2-3n+2$</font><font size=4>圆形，两个圆形最大交点数：$2$，$T_n=n^2-n+2$</font><font size=4>椭圆形，两个椭圆形最大交点数：$4$，$T_n=2n^2-2n+2$</font><font size=4>因此，我们可以大胆猜测：封闭二次型曲线，两条曲线的最大交点数：$m$，$T_n=kn^2-kn+2, k=\dfrac{m}{2}$</font><font size=4>**多么优美的公式！**</font><hr><h2 id="三、多维切割问题："><a href="#三、多维切割问题：" class="headerlink" title="三、多维切割问题："></a>三、多维切割问题：</h2><font size=4>这个问题的难度很大，我只讲讲最基础的平面切割三维空间的问题，其他的多维的我只例举一些有用的公式就好了。</font><h3 id="1、-n-个平面切割一个空间，最多可以得到多少个不同的空间？"><a href="#1、-n-个平面切割一个空间，最多可以得到多少个不同的空间？" class="headerlink" title="1、$n$个平面切割一个空间，最多可以得到多少个不同的空间？"></a>1、$n$个平面切割一个空间，最多可以得到多少个不同的空间？</h3><font size=4>为了要有最多的空间数，则第$n$个平面需与前$n-1$个平面相交，且不能有共同的交线。所以最多有$n-1$ 条交线。而这些交线把第$n$个平面最多分割成多少个区域呢？</font><font size=4>显然，这最多可以分出$L_{n-1}$个区域，这个平面将原来的空间一分为二，所以只会一部分空间被区域分割，总的增加$L_{n-1}$个空间：</font><script type="math/tex; mode=display">T_n=T_{n-1}+L_{n-1}</script><h3 id="2、-n-个-d-1-维度的物体切割一个-d-维度的物体，最多可以得到多少份？"><a href="#2、-n-个-d-1-维度的物体切割一个-d-维度的物体，最多可以得到多少份？" class="headerlink" title="2、$n$个$d-1$维度的物体切割一个$d$维度的物体，最多可以得到多少份？"></a>2、$n$个$d-1$维度的物体切割一个$d$维度的物体，最多可以得到多少份？</h3><font size=4>根据递归的思想，我们可以得到该问题的解：</font><script type="math/tex; mode=display">T_d(n)=T_d(n-1)+T_{d-1}(n-1)</script><script type="math/tex; mode=display">T_d(n)=\sum_{k=0}^d \binom{n}{k}</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汉诺塔变形问题</title>
      <link href="/2022/05/26/%E6%B1%89%E8%AF%BA%E5%A1%94%E5%8F%98%E5%BD%A2%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/26/%E6%B1%89%E8%AF%BA%E5%A1%94%E5%8F%98%E5%BD%A2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="汉诺塔变形问题"><a href="#汉诺塔变形问题" class="headerlink" title="汉诺塔变形问题"></a>汉诺塔变形问题</h2><h4 id="此文章凝聚了所有我对汉诺塔问题的理解，没有配图，在我看来，严谨的文字表达比图片更加容易理解，其实是我太懒，逃"><a href="#此文章凝聚了所有我对汉诺塔问题的理解，没有配图，在我看来，严谨的文字表达比图片更加容易理解，其实是我太懒，逃" class="headerlink" title="==此文章凝聚了所有我对汉诺塔问题的理解，没有配图，在我看来，严谨的文字表达比图片更加容易理解，其实是我太懒，逃=="></a>==<del>此文章凝聚了所有我对汉诺塔问题的理解，没有配图，在我看来，严谨的文字表达比图片更加容易理解，其实是我太懒，逃</del>==</h4><h5 id="1、汉诺塔的盘子不能直接从最左边的柱子放到最右边的柱子，而是要经过中间的柱子后，才能把盘子放到右边的柱子上，初始状态为所有的盘子都是在最左边的柱子，问把所有的盘子-转移到最右边的柱子需要的最少步骤数？"><a href="#1、汉诺塔的盘子不能直接从最左边的柱子放到最右边的柱子，而是要经过中间的柱子后，才能把盘子放到右边的柱子上，初始状态为所有的盘子都是在最左边的柱子，问把所有的盘子-转移到最右边的柱子需要的最少步骤数？" class="headerlink" title="1、汉诺塔的盘子不能直接从最左边的柱子放到最右边的柱子，而是要经过中间的柱子后，才能把盘子放到右边的柱子上，初始状态为所有的盘子都是在最左边的柱子，问把所有的盘子 转移到最右边的柱子需要的最少步骤数？"></a><font size=4><strong>1</strong>、汉诺塔的盘子<strong>不能直接从最左边的柱子放到最右边的柱子，而是要经过中间的柱子后，才能把盘子放到右边的柱子上</strong>，初始状态为所有的盘子都是在最左边的柱子，问把所有的盘子 转移到最右边的柱子需要的最少步骤数？</font></h5><font size=4>解决方案：先把除了最大的盘子的其他所有的盘子移动到右边的柱子需要$T_{n-1}$步数，再把最大的盘子放到中间的柱子，需要$1$步，把右边的一坨盘子转移到左边的柱子需要$T_{n-1}$步数，然后把中间的最大的盘子移动到右边的柱子上，需要一步，最后再把左边的一坨盘子移动到右边的盘子需要$T_{n-1}$步，所以总共需要的步数为：</font><script type="math/tex; mode=display">T_n = 3*T_{n-1}+2</script><script type="math/tex; mode=display">T_n = 3^n-1</script><hr><h5 id="2、经典的汉诺塔问题是三个柱子，现在柱子有四个，求问题的解？"><a href="#2、经典的汉诺塔问题是三个柱子，现在柱子有四个，求问题的解？" class="headerlink" title="2、经典的汉诺塔问题是三个柱子，现在柱子有四个，求问题的解？"></a><font size=4><strong>2</strong>、经典的汉诺塔问题是三个柱子，现在柱子有四个，求问题的解？</font></h5><font size=4>解决方案：首先考虑经典的三个柱子的问题，规定如下：</font><ul><li><font size=4>$D_n$表示在==三个柱子的情况下==问题的解，也就是经典的汉诺塔问题的答案。</font></li><li><font size=4>$T_n$表示在==四个柱子的情况下==问题的解，也就是本题的答案。</font></li></ul><font size=4>采用枚举的==试探性解法==，首先尝试把前面的$i$个小的盘子在==四个柱子==的情况下转移到一个柱子上，需要花费$T_i$步，然后把剩下的的一坨盘子在==三个柱子==的模式下面转移到另一个柱子上面，花费$D_{n-i}$步，最后在==四个柱子==的模式下转移最后的$i$个盘子，花费$T_i$步，所有总共花费的最小步数为：</font><script type="math/tex; mode=display">T_n=min_{1 \le i < n} \{2*T_i+D_{n-i}\}</script><font size=4>然而，这只是我们基于试探法所得到的最优解，事实上，严谨来说，应该只能得到下面的不等式：</font><script type="math/tex; mode=display">T_n \le 2*T_{n-k}+D_k (0 \le k <n)</script><font size=4>只不过后来有人证明了这个算法就是最优解，真的很强。</font><!---<font size=4>推广无限个柱子的汉诺塔问题：假设$T^{(k)}(n)$是具有$k$个辅助柱子移动$n$个盘子的汉诺塔问题的解，其中有$T^{(1)}(n)=D_n$，$T^{(2)}(n)=T_n$，那么它满足下面的不等式：</font>--- ><!---$$T^{(k)} \left(\binom{n+1}{k}\right) \le 2*T^{(k)}\left(\binom{n}{k} \right)+T^{(k-1)}\left(\binom{n}{k-1} \right)$$---><hr><h5 id="3、环形汉诺塔，所有的盘子的移动都必须按照顺时针的方向，比如A可以直接到C，但是C不能直接返回到A，（还是弄了张图片），求在这种规则下，盘子从-A-到-B-的最少移动步数，盘子从-B-到-A-的最少移动步数，规定如下："><a href="#3、环形汉诺塔，所有的盘子的移动都必须按照顺时针的方向，比如A可以直接到C，但是C不能直接返回到A，（还是弄了张图片），求在这种规则下，盘子从-A-到-B-的最少移动步数，盘子从-B-到-A-的最少移动步数，规定如下：" class="headerlink" title="3、环形汉诺塔，所有的盘子的移动都必须按照顺时针的方向，比如A可以直接到C，但是C不能直接返回到A，（还是弄了张图片），求在这种规则下，盘子从$A$到$B$的最少移动步数，盘子从$B$到$A$的最少移动步数，规定如下："></a><font size=4><strong>3</strong>、环形汉诺塔，<strong>所有的盘子的移动都必须按照顺时针的方向，比如A可以直接到C，但是C不能直接返回到A，（还是弄了张图片）</strong>，求在这种规则下，盘子从$A$到$B$的最少移动步数，盘子从$B$到$A$的最少移动步数，规定如下：</font></h5><ul><li><font size=4>$Q_n$表示盘子移动到==下一个柱子==的最少移动步数</font></li><li><font size=4>$T_n$表示盘子移动到==下两个柱子==的最少移动步数。</font></li></ul><p><img src="https://img-blog.csdnimg.cn/98fb107c57bb4dbb900b1d602a58943d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>$Q_n$的解决方案：假设我要把盘子从$A$移动到$C$，那么我要把$n-1$个盘子从$A$移动到$B$，耗费$T_{n-1}$步数，然后再把第$n$个盘子从$A$移动到$C$，需要一步，最后再把$n-1$个盘子从$B$移动到$C$需要$T_{n-1}$步，因此可以得到：</font><script type="math/tex; mode=display">Q_n = 2*T_{n-1}+1</script><font size=4>$T_n$的解决方案：假设我要把盘子从$A$移动到$B$，那么我要把$n-1$个盘子从$A$移动到$B$，耗费$T_{n-1}$步数，然后再把第$n$个盘子从$A$移动到$C$，需要一步，再把$n-1$个盘子从$B$移动到$A$需要$Q_{n-1}$步，然后再把第$n$个盘子从$C$移动到$B$，需要一步，最后把$n-1$个盘子从$A$移动到$B$需要$T_{n-1}$步，因此可以得到：</font><script type="math/tex; mode=display">T_n=T_{n-1}+1+Q_{n-1}+1+T_{n-1}</script><script type="math/tex; mode=display">T_n=Q_n+Q_{n-1}+1</script><font size=4>联立上面的两个方程可以得到：</font><script type="math/tex; mode=display">\begin{cases} Q_n = 2*T_{n-1}+1 \\ T_n=Q_n+Q_{n-1}+1\end{cases}</script><font size=4>思想过程才是最重要的，这里求通项公式有难度，所以就直接给出结果：</font><script type="math/tex; mode=display">Q_n= \left( (1+\sqrt3)^{n+1}-(1-\sqrt3)^{n+1} \right) / (2\sqrt3)-1</script><hr><h5 id="4、双重汉诺塔，此时的初始状态中柱子上的圆盘有-2n-个，有-n-种不同的尺寸，每一种尺寸的圆盘有两个，如果相同尺寸的圆盘是-相互不可区分-的，问：把所有的盘子都移动到另一个柱子上的所需要的最少步数？规定初始盘子都在左边的柱子上。"><a href="#4、双重汉诺塔，此时的初始状态中柱子上的圆盘有-2n-个，有-n-种不同的尺寸，每一种尺寸的圆盘有两个，如果相同尺寸的圆盘是-相互不可区分-的，问：把所有的盘子都移动到另一个柱子上的所需要的最少步数？规定初始盘子都在左边的柱子上。" class="headerlink" title="4、双重汉诺塔，此时的初始状态中柱子上的圆盘有$2n$个，有$n$种不同的尺寸，每一种尺寸的圆盘有两个，如果相同尺寸的圆盘是==相互不可区分==的，问：把所有的盘子都移动到另一个柱子上的所需要的最少步数？规定初始盘子都在左边的柱子上。"></a><font size=4><strong>4</strong>、双重汉诺塔，<strong>此时的初始状态中柱子上的圆盘有$2n$个，有$n$种不同的尺寸，每一种尺寸的圆盘有两个</strong>，如果相同尺寸的圆盘是==相互不可区分==的，问：把所有的盘子都移动到另一个柱子上的所需要的最少步数？规定初始盘子都在左边的柱子上。</font></h5><font size=4>解决方案：其实和解决经典的汉诺塔问题思路类似，先把除了最大的==两个==盘子的其他所有的盘子移动到中间柱子需要$A_{n-1}$步数，再把最大的==两个==盘子放到右边柱子，需要$2$步，然后把剩下的一坨盘子转移到右边的柱子需要$A_{n-1}$步数，所以总共需要的步数为：</font><script type="math/tex; mode=display">A_n = 2*A_{n-1}+2</script><script type="math/tex; mode=display">A_n = 2^{n+1}-2</script><font size=4>假如一对于尺寸为$k$的盘子恰好有$m_k$个，那么也就有：</font><script type="math/tex; mode=display">A(m_n, m_{n-1}, m_{n-2},...,m_1)=2*A(m_{n-1}, m_{n-2}, ...,m1)+m_n</script><font size=4>**另外一种双重汉诺塔**：尺寸相同的两个盘子==相互可以区分==，转移结束后保证盘子排列结果为原来的顺序，问最少的步数？在这里，我们同样规定在这种规则下的最优解为$B_n$。</font><font size=4>解决方案：其实思路也是差不多的，首先要把除了最大的两个盘子的其他所有的盘子移动到中间的空柱子需要$A_{n-1}$步数，然后再把尺寸为$n$的两个盘子移动到右边的空柱子上，需要$2$步，注意此时它们的顺序和原来的顺序相反，然后再把那坨不是最大的盘子移回到左边的柱子上，需要$A_{n-1}$步数，然后再把那两个尺寸为$n$的盘子移动到中间的柱子上，需要$2$步，最后再把左边的盘子移动到中间要$B_{n-1}$步数。所以总共的步数为：</font><script type="math/tex; mode=display">B_n=A_{n-1}+2+A_{n-1}+2+B_{n-1}</script><font size=4>**这里有一个细节的地方，那就是转移小盘子的时候为什是$A_{n-1}$步数而不是$B_{n-1}$步数？** 事实上，根据上面的$A_n$的转移规则，可以看到转移后相同尺寸大小的盘子顺序刚好是相反的，==一去一回，顺序不就恰好是原来的顺序吗！并且显而易见的是$A_n \le B_n$，因此这个方法是最优的。==</font><script type="math/tex; mode=display">B_n=2^{n+2}-5=2*A_n-1</script><font size=4>这恰好说明了，为了保证顺序，我们可以连续两次移动盘子，这样的策略的步骤数为$2*A_n$，但是$B_n$的策略却少了一步？到底是哪一步？不妨在$n=1$的情况下看看差别。</font><p><img src="https://img-blog.csdnimg.cn/09b75849fc884b75be861a15c600f3a7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="这是A的情况"></p><center size=4>这是第一种的情况</center><p><img src="https://img-blog.csdnimg.cn/ff0e7440ca614fdfb8a7076358ad215d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><center size=4>这是第二种的情况</center>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>递归，从三个数学问题开始</title>
      <link href="/2022/05/26/%E9%80%92%E5%BD%92%EF%BC%8C%E4%BB%8E%E4%B8%89%E4%B8%AA%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B/"/>
      <url>/2022/05/26/%E9%80%92%E5%BD%92%EF%BC%8C%E4%BB%8E%E4%B8%89%E4%B8%AA%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、汉诺塔问题（THE-TOWEL-OF-HANOI）"><a href="#一、汉诺塔问题（THE-TOWEL-OF-HANOI）" class="headerlink" title="一、汉诺塔问题（THE TOWEL OF HANOI）"></a>一、汉诺塔问题（THE TOWEL OF HANOI）</h2><font size=4>hanoi塔问题是法国数学家卢卡斯发明的问题，简单的说就是给你三根柱子，其中初始阶段所有的$n$盘子都按照==从大到小==放置到一条柱子上。**~~如果你觉得表述不清楚，那么请百度这个问题。~~**，现在的问题是：如何移动盘子可以使用==最少==的步骤把所有的盘子移动到另一个柱子上？==在任意时刻，大盘子都在小盘子的下面。==</font><hr><font size=4>**1**、对于这种复杂的问题，先研究小的情形往往是大有裨益的。我们规定对于$n$个盘子来说，该问题的最优解为$T_n$</font><ul><li>$n==1:$ <font size=4>显然最少的步骤数为$T_1=1$</font></li><li>$n==2:$ <font size=4>先把最小的放到一个柱子上，然后把大的一个放到另一个柱子上，最后再把小的放到大的上面，显然最少的步骤数为$T_2=3$</font></li><li><p>$n==3:$ <font size=4>，手动推导一下，显然最少的步骤数为$T_3=7$</font></p><font size=4>**2**、现在我们来研究盘子数为$n$的问题的解，从上面的小的情形可以知道，问题的解决思路就是 **==先把除了最大的所有的盘子都移动一个柱子上==**，耗费$T_{n-1}$步骤数，然后 **==再把最大的那个盘子放到另一个柱子上==** ，需要一步，**==最后再把其他盘子想办法转移动最大盘子所在的柱子上面==**，耗费$T_{n-1}$步骤数。所以可以得到：</font></li></ul><script type="math/tex; mode=display">T_n \le 2*T_{n-1}+1</script><font size=4>为什么是小于等于呢？这里其实是严谨的，对于上面的思路来说，**我们只是证明了上限，即使用这个思路的话我们最多需要多少步骤，但是我们并没有证明这个思路一定是最少的方法，如果还有更好的方法呢？** 实际上并没有，因为必定要走的一步是把最大的盘子放到一个空的柱子上，而在这之前至少需要$T_{n-1}$步，而在这之后也就至少需要把剩下的盘子转移到最大的盘子所在的柱子上。因此有：</font><script type="math/tex; mode=display">T_n \ge 2*T_{n-1}+1</script><font size=4>综合上面的讨论可以知道，我们可以得到一个递推关系表达式，这里我是用《具体数学》里面的叫法，叫做**递归式**：<font>$$T_n = 2*T_{n-1}+1$$<font size=4>这是一个很重要的式子，这表明所有规模的问题都有解，并且可以通过连续的递归得到。那么什么是递归？隐约中，能不能感受到递归的思想？有的人很喜欢区别递归和递推，其实在本质上它们二者有着巨大的联系。下面开始讨论。</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归的问题写法</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cal</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">cal</span>(x - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推写法，我更喜欢叫做迭代</span></span><br><span class="line">t[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">t[i] = <span class="number">2</span> * t[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>那么从上面的代码可以看出：**递归的本质：把大规模的问题转换为小规模问题进行求解，自顶向下。****递推的本质：自底向上，从小的问题开始向上求解规模大的问题。****共同的特点：问题的求解具有状态可转移的特性，即问题的求解并不是绝对独立的。**~~个人觉得动态规划的本质也是属于这些问题，递归和递推分别表示了两种不同的写法：搜索和迭代刷表。其实我个人认为，它们都是基于分治的思想。~~</font><hr><h2 id="二、平面直线问题（LINES-IN-THE-PLANE）"><a href="#二、平面直线问题（LINES-IN-THE-PLANE）" class="headerlink" title="二、平面直线问题（LINES IN THE PLANE）"></a>二、平面直线问题（LINES IN THE PLANE）</h2><font size=4>这个问题很简单：平面上$n$条直线最多能够将平面划分为多少个区域？</font><font size=4>**1**、对于这个问题，我们还是先研究小的情形。我们规定对于$n$条直线来说，该问题的最优解为$T_n$</font><ul><li>$n==0:$ <font size=4>显然区域的数量为$T_0=1$</font></li><li>$n==1:$ <font size=4>显然区域的数量最多为$T_1=2$</font></li><li>$n==2:$ <font size=4>两条直线相交，最多可以得到区域数量$T_2=4$</font></li><li><p>$n==3:$ <font size=4>三条直线两两相交，手动推导一下，显然最多的区域数为$T_3=7$</font></p><font size=4>**2**、现在我们来研究盘子数为$n$的问题的解，从上面的小的情形可以知道，问题的解决思路就是 **==每一次加上的线都尽量去与所有已有的直线相交，这样可以切割更多的区域==**，对于问题规模为$n$的时候而言，当且仅当第$n$条直线与已有的$n-1$条直线相交时，可以切割出多的$n$个区域。那么可以得到：</font></li></ul><script type="math/tex; mode=display">T_n \le T_{n-1}+n</script><font size=4>事实上，对于第$n$条直线，**我们保证取一个位置，使得它与已有的直线都不平行**，那么可以取等号。即：</font><script type="math/tex; mode=display">T_n = T_{n-1} + n</script><font size=4>至此，该问题已经得到了解答，可以发现解题的思路和hanoi塔的问题思路一模一样，都是基于递归式求解。</font><p><img src="https://img-blog.csdnimg.cn/9ec9cb6d03424b7b951cc61e87f2bb3c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt=""></p><p><img src="https://img-blog.csdnimg.cn/28ad975305f044529d7812c220d15737.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="两条直线相交"></p><p><img src="https://img-blog.csdnimg.cn/8c04de86247344ee99cebe4fbf582c8f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><hr><h2 id="三、约瑟夫问题（THE-JOSEPHUS-PROBLEM）"><a href="#三、约瑟夫问题（THE-JOSEPHUS-PROBLEM）" class="headerlink" title="三、约瑟夫问题（THE JOSEPHUS PROBLEM）"></a>三、约瑟夫问题（THE JOSEPHUS PROBLEM）</h2><font size=4>这个问题非常巧妙，相传是在一个洞穴内，数十名反抗者不想被敌人杀死，决定自杀的故事。所有的人都围坐成一个圆圈，每隔一个人就自杀一次，约瑟夫不想死，他一下子就找到了幸存者的位置。</font><font size=4>**1**、对于这个问题，我们还是先研究小的情形。我们规定对于$n$个人来说来说，该问题的幸存者编号为$T_n$</font><font size=4>假设这里有$11$个人：</font><p><img src="https://img-blog.csdnimg.cn/d48d7280480e4466a2e2102e917ebdb7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>第一轮死掉的人分别是: $2, 4, 6, 8, 10, 1$</font><p><img src="https://img-blog.csdnimg.cn/4d0c1578c8194bf1901eee38be164db5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>第二轮死掉的人为：$3, 7, 11$</font><p><img src="https://img-blog.csdnimg.cn/1fa610bf9ef54e349f35812e542e7a7f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>第三轮，已经可以知道幸存者的编号就是$5$，因为接下来死的是$9$。</font>  <font size=4>**2**、现在我们来研究人数为$n$的问题的解，从上面的小的情形可以知道，问题的解决思路就是 **==每一轮刷人之后，剩下的人会组成一个新的约瑟夫环，只是编号有点不同，但是只要做适当的变换，就可以发现一个奇妙转换==**，观察下面的两幅图片，那么可以得到：</font><ul><li>$3 = 2*1 + 1$</li><li>$5 = 2*2 + 1$</li><li>$7 = 2*3 + 1$</li><li>$9 = 2*4 + 1$</li><li><p>$11 = 2*5 + 1$</p><font size=4>显然下面的约瑟夫环的解为 $T=2*T_5+1$</font></li></ul><p><img src="https://img-blog.csdnimg.cn/5397858582074c34a5f5de942e89ff9a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/fb12d8a7c3b54795a0917e4e4e08d60d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>事实上，对于人数为==偶数==的情况，有递归式：</font><script type="math/tex; mode=display">T_{2n} = 2*T_n - 1</script><font size=4>事实上，对于人数为==奇数==的情况，有递归式：</font><script type="math/tex; mode=display">T_{2n+1} = 2*T_n +1</script><font size=4>至此，该问题已经得到了解答，可以发现解题的思路和上面的两个问题思路一模一样，都是基于递归式求解。</font>                                    ]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>五分钟了解编译，链接和可执行文件</title>
      <link href="/2022/05/26/%E4%BA%94%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%EF%BC%8C%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
      <url>/2022/05/26/%E4%BA%94%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%EF%BC%8C%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="源文件的编译和可执行文件"><a href="#源文件的编译和可执行文件" class="headerlink" title="源文件的编译和可执行文件"></a>源文件的编译和可执行文件</h2><h4 id="head-id">开始</h4><ul><li><a href="#1">编译</a></li><li><a href="#2">链接</a></li><li><a href="#3">执行</a></li></ul><ol><li><font size = 4>不同的代码（**cpp,python,c,java**）都是会编译称为相同的<mark><font color=red>本地代码</font></mark>,本地代码就是类似于机器语言的母语，本地代码就是转换为机器语言的程序。</font></li><li><font size = 4> **exe**文件使用的就是本地代码，将每一个字节使用两位十六进制的数字表示，就可以得到本地代码的真实面目,<mark>这个过程叫做(***Dump***)</mark></font></li><li><font size = 4>**编译器的三大特点**：<b><font color="blue">- 编程语言- 生成的代码作用的CPU- 哪种环境下运行的(**运行环境=操作系统+硬件**)</font></b></font></li><li><p><font size=4>从源代码到可执行文件：</p><ul><li><h5 id="1">编译</h5><ul><li><blockquote><p>gcc -o -w helloworld.cpp</p></blockquote><p>上面的命令会生成一个<font color=red>.obj</font>格式的文件，称为目标文件。目标文件不是可执行文件，因为没有执行链接。</p></li></ul></li><li><h5 id="2">链接:</h5><ul><li><p><mark>链接的过程就是把多个目标文件结合形成一个可执行文件的过程</mark>,分为下面两种：</p><ul><li><strong>使用库文件</strong>：<ul><li>静态链接库：库文件，格式为<font color=red>.lib</font>,包含了一些已经写好的函数的<strong>比如标准库函数</strong>的目标文件，</li><li>动态链接库（导入库）：仅仅包含了一些<font color=red>函数</font>的<strong>文件夹信息</strong>和<strong>函数的处于哪个dll文件</strong>的信息，有的时候并不一定要使用导入库，只要能够在动态链接的过程中使用<strong>dll</strong>函数就行，注意动态链接并不是把目标文件结合的过程，而是类似于一种<strong>API</strong>的调用。</li></ul></li><li><strong>不使用库文件</strong>：<ul><li>在执行链接的过程中要手动添加所需要的目标文件。</li></ul></li></ul></li><li><p><mark><strong>启动:</strong></mark></p><ul><li>就算不需要额外的函数或者<strong>API（Windows提供的程序应用接口）</strong>,目标文件也一定要执行链接，原因在与可执行文件一定要包含一个<strong>启动</strong>的目标文件，这是编译器提供的，它包含了程序的起始位置相结合的内容。</li></ul></li></ul></li><li><h5 id="3">执行:</h5><ul><li>可执行文件生成后如果需要运行会被加载到内存中，同时产生<strong>栈和堆</strong>:<ul><li>栈：用于保存函数执行时<mark><strong>临时的变量数据以及函数调用的所需要的空间</strong></mark>的内存区域。这就很容易解释为什么需要把大内存的变量数据放到主函数外面，因为主函数里面所用到的所有内存都是在一个栈中。在执行处理数据的操作结束后，相应的内存会被清理掉。</li><li>堆：用于保存程序执行时所有数据和对象的内存领域。</li><li><mark><strong>堆和栈都是在程序执行的过程中申请分配的</strong></mark>,如果没有及时清理掉内存，那么这个内存就会一直存在，处于使用状态，称作<mark><strong><em>内存泄漏</em></strong></mark>。这是十分麻烦的漏洞，很容易造成机器内存不足宕机。但是部分高级语言<font color=green size = 5>java,python,C#</font>由于拥有高级的垃圾回收机制，会自动清理内存，防止内存泄漏。</li></ul></li><li><strong>再配置信息</strong>：<ul><li>链接器会在可执行文件的开头配置程序执行的<strong>基址</strong>，所有的变量、函数的地址都是<strong>连续</strong>的分布在基址后面的内存中，<font color=red>注意程序里面的地址都是虚拟地址，并不是真正的物理地址，为了保证多个程序运行时不会发生内存冲突，多个程序的里面的虚拟地址可能相同，但是由于程序的基址不同，真正的物理地址是不一样的</font>。</li></ul></li><li><strong>程序运行的内存=变量组的大小+函数组的大小+栈空间+堆空间+操作系统空间</strong></li></ul></li></ul></li><li><p>一些名词：</p><ul><li><strong>分割编译</strong>：源文件分为多个文件，编译器编译的过程中就会产生多个目标文件，链接的时候多个目标文件就会结合到一个可执行文件中。但是，多文件的好处在于方便代码的管理。</li><li><strong>叠加链接</strong>：有些函数一定不会同时执行，那么将他们交替加载到同一个内存地址中运行，就可以节省内存空间。</li><li><strong>dll文件的好处</strong>：<ul><li>可以被多个程序同时使用，节省代码，节省内存空间。</li><li>修改的时候不需要重新链接并且导入到链接库中，只需要修改<font color=red>dll</font>文件。&lt;/font&gt;</li></ul></li></ul></li></ol><p><a href="#head-id">回到开头</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树和子段和，一篇就够</title>
      <link href="/2022/05/26/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E5%AD%90%E6%AE%B5%E5%92%8C/"/>
      <url>/2022/05/26/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="1、经典的区间最大子段和问题"><a href="#1、经典的区间最大子段和问题" class="headerlink" title="1、经典的区间最大子段和问题"></a>1、经典的区间最大子段和问题</h2><font size=4>问题描述：给定一个序列$a_1,a_2, a_3,..a_n$，如何求出该序列的最大子段和？（询问的区间个数为$m$）</font><font size=4>解决方案：</font><font size=4> - **暴力统计**：对于每一个区间$[l,r]$，每一次选定一个子段的起点，然后枚举子段的长度，算法复杂度为$O(mn^2)$。</font><font size=4> - **动态规划**：我们一次性算出所有的区间的最大子段和，然后使用直接询问答案。我们规定：</font><font size=4> - $\color{Green}ls$: 表示区间紧靠左端点的子段的最大和</font> <font size=4>- $\color{Blue}rs$: 表示区间紧靠右端点的子段的最大和</font> <font size=4>- $\color{OrangeRed}ms$: 表示区间子段的最大和</font><font size=4> - $\color{Blue}s$：表示区间子段和。</font><font size=4>假设一个区间为$[l,r]$，我们将它一分为二，并且我们假设已经得到了左边区间和右边区间的各自的四样所有信息，那么我们如何求出这个区间的的四个信息呢？</font><font size=4></font><font size=4>显然有：</font><font size=5>$$s=s_l+s_r$$</font><p><img src="https://img-blog.csdnimg.cn/d184e410f63a4122af5aab42bd7a8327.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>求解$ls$，那么我们有两个选择，选择左边区间的$ls$，或者是把左边区间全部选了然后再选取右边区间的$ls$。因为子段必须保持连续性，所以这两个选择是最优的。</font><font size=5>$$ls=max(ls_l, s_l+ls_r)$$</font><p><img src="https://img-blog.csdnimg.cn/3dda0d5c84ee4dd582f00c98564c05ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>同样道理求解$rs$，那么我们有两个选择，选择右边区间的$rs$，或者是把右边区间全部选了然后再选取左边区间的$rs$。因为子段必须保持连续性，所以这两个选择是最优的。</font><font size=5>$$rs=max(rs_r, s_r+rs_l)$$</font><p><img src="https://img-blog.csdnimg.cn/d1b75e5cbbba4cafb6f466032783a6e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>求解$ms$，那么我们有两个选择，选择右边区间的$ms$，或者是左边区间的$ms$，或者是左边区间的$rs$和右边区间的$ls$的和，因为选择保证了连续子段的连续性，所以最优解一定在上面三种选择中。</font><font size=5>$$ms=max(ms_r, ms_r, rs_l+ls_r)$$</font><p><img src="https://img-blog.csdnimg.cn/bb23010aaa504cfc92fbcd568b483e48.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>到此，我们完成了区间合并的工作，那么我们就可以使用区间合并的方式进行动态规划。</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line">ll n, m, a[maxn], val[maxn], ql, qr;</span><br><span class="line">ll ls[maxn][maxn], ms[maxn][maxn], rs[maxn][maxn], s[maxn][maxn]; <span class="comment">// 使用区间作为下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; val[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ls[i][i] = ms[i][i] = rs[i][i] = s[i][i] = val[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> r = i + len - <span class="number">1</span>, l = i;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">            s[l][r] = s[l][mid] + s[mid+<span class="number">1</span>][r];</span><br><span class="line">            ls[l][r] = <span class="built_in">max</span>(ls[l][mid], ls[mid+<span class="number">1</span>][r] + s[l][mid]);</span><br><span class="line">            rs[l][r] = <span class="built_in">max</span>(rs[mid+<span class="number">1</span>][r], rs[l][mid] + s[mid+<span class="number">1</span>][r]);</span><br><span class="line">            ms[l][r] = <span class="built_in">max</span>(<span class="built_in">max</span>(ms[l][mid], ms[mid+<span class="number">1</span>][r]), ls[mid+<span class="number">1</span>][r] + rs[l][mid]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; ql &gt;&gt; qr;</span><br><span class="line">        cout &lt;&lt; ms[ql][qr] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4> 由上面的代码可知，合并的区间越来越大，第一轮合并的区间为$n$个，第二轮合并的区间为$\dfrac{n}{2}$个，第三轮合并的区间为$\dfrac{n}{4}$个，所以总的合并区间个数约为$2n$个，总的复杂度为：$O(n+m)$，非常优秀！</font><font size=4> - **线段树**：我们可以使用动态规划可以非常快速地一次性算出所有的区间的最大子段和，然后使用直接询问答案。但是如果操作带修改的序列时，又如何设计更好的算法？那么线段树就可以大显神通了！==如果你学过线段树，你就会发现这个问题真的是和线段树天生一对啊！区间合并，单点修改，优秀的$O(\log n)$的复杂度!==</font><font size=4>下面是推荐的练习的题目：[SP1716](https://www.luogu.com.cn/problem/SP1716) </font><font size=6>$\color{Green}{AC} \, \color{Red}{Code}$</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> <span class="comment">// 万能头文件</span></span></span><br><span class="line"><span class="comment">// 使用宏定义来写线段树，节省代码量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson lc, l, mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rc, mid + 1, r</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> ll inf = <span class="number">2e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123; ll ms, ls, rs, s;&#125; tr[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上更新的操作就是区间合并的操作，我们在这里加入动态规划的核心操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    tr[rt].s = tr[lc].s + tr[rc].s;</span><br><span class="line">    tr[rt].ls = <span class="built_in">max</span>(tr[lc].ls, tr[rc].ls + tr[lc].s);</span><br><span class="line">    tr[rt].rs = <span class="built_in">max</span>(tr[rc].rs, tr[lc].rs + tr[rc].s);</span><br><span class="line">    tr[rt].ms = <span class="built_in">max</span>(<span class="built_in">max</span>(tr[lc].ms, tr[rc].ms), tr[lc].rs + tr[rc].ls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;tr[rt].s);</span><br><span class="line">        tr[rt].ls = tr[rt].rs = tr[rt].ms = tr[rt].s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(lson);</span><br><span class="line">    <span class="built_in">build</span>(rson);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 单点修改，然后往上合并</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        tr[rt].s = tr[rt].ms = tr[rt].ls = tr[rt].rs = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) <span class="built_in">modify</span>(lson, pos, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(rson, pos, val);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的查询操作和动态规划是一个思路。</span></span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[rt];</span><br><span class="line">    node x, y, w;</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) w = <span class="built_in">query</span>(lson, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) w = <span class="built_in">query</span>(rson, L, R);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        x = <span class="built_in">query</span>(lson, L, mid);</span><br><span class="line">        y = <span class="built_in">query</span>(rson, mid + <span class="number">1</span>, R);</span><br><span class="line">        w.s = x.s + y.s;</span><br><span class="line">        w.ls = <span class="built_in">max</span>(x.ls, x.s + y.ls);</span><br><span class="line">        w.rs = <span class="built_in">max</span>(y.rs, y.s + x.rs);</span><br><span class="line">        w.ms = <span class="built_in">max</span>(<span class="built_in">max</span>(x.ms, y.ms), x.rs + y.ls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="keyword">if</span>(x) &#123;</span><br><span class="line">            node ans = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, y, z);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans.ms);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>复杂度分析：查询操作复杂度为$O(\log n)$， 修改的复杂度为$O(\log n)$，总的复杂度为$O(n+m\log n)$。下面所有的变形问题，我们都使用线段树解决。</font><hr><h2 id="2、区间最大子段和变形问题1"><a href="#2、区间最大子段和变形问题1" class="headerlink" title="2、区间最大子段和变形问题1"></a>2、区间最大子段和变形问题1</h2><font size=4>问题描述：给定一个序列$a_1,a_2, a_3,..a_n$，给定$m$个区间组合，对于每一个区间组合$[x_1,y_1], \, [x_2, y_2]$，问对于左端点在$[x_1,y_1]$并且右端点在$[x_2,y_2]$的所有区间的最大子段和。</font><font size=4>**解决方案**：其实就是经典最大子段和问题的一个小变形，我们可以把区间组合的两个区间进行分类讨论：</font><ul><li><font size=4>两个区间没有交集，那么这时候很好办，**==因为要满足子段的连续的特性，所以中间的一段是必须要选择的==**，因此最优解就是：</font></li></ul><font size=5>$$ms=sum(r_1, l_2)+rs_{l_1, r_1}+ls_{l_2, r_2}$$</font><p><img src="https://img-blog.csdnimg.cn/40771820f69f47bf8507a0ee3cb4f695.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li><font size=4>两个区间有交集，那么也可以分为三种情况：</font>  - <font size=4>子段只在区间$[l_2,r_1]$中，此时的最大值为$ms_1=ms_{l_2,r_1}$</font>  - <font size=4>子段不只是在区间$[l_2,r_1]$中，**==为了满足连续性，所以必定是一头选左最大子段和，一头选右最大子段和==**：</font>      - <font size=4>第一种情况$ms_2=ls_{l_1,l_2}+rs_{l_2+1, r_2}$</font>      - <font size=4>第二种情况$ms_3=ls_{l_1,r_1}+rs_{r_1+1, r_2}$</font></li></ul><p><img src="https://img-blog.csdnimg.cn/84b922ecad344d04b370a22c852ebcff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><center size=4>第一种情况</center><p><img src="https://img-blog.csdnimg.cn/8ff1c454614a4a2aa42739540385d50f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><center size=4>第二种情况</center><font size=4>因此有最后的答案为：</font><font size=5>$$ms=max(ms_1,ms_2,ms_3)$$</font><font size=4>这也恰好对应了线段树的查找答案的方法！</font><font size=5>例题：[SP2916](https://www.luogu.com.cn/problem/SP2916) </font><font size=6>$\color{Green}{AC} \, \color{Red}{Code}$</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson ls, l, mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rs, mid + 1, r</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll N = maxn * <span class="number">4</span>;</span><br><span class="line">ll n, m, t, num[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    ll sum, lx, rx, mx;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(ll _s, ll _l, ll _r, ll _m):</span><br><span class="line">            <span class="built_in">sum</span>(_s), <span class="built_in">lx</span>(_l), <span class="built_in">rx</span>(_r), <span class="built_in">mx</span>(_m)&#123;&#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间合并操作，和经典问题是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(ll rt)</span> </span>&#123;</span><br><span class="line">    a[rt].sum = a[ls].sum + a[rs].sum;</span><br><span class="line">    a[rt].lx = <span class="built_in">max</span>(a[ls].lx, a[ls].sum + a[rs].lx);</span><br><span class="line">    a[rt].rx = <span class="built_in">max</span>(a[rs].rx, a[rs].sum + a[ls].rx);</span><br><span class="line">    a[rt].mx = <span class="built_in">max</span>(<span class="built_in">max</span>(a[ls].mx, a[rs].mx), a[ls].rx + a[rs].lx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll rt, ll l, ll r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;num[l]);</span><br><span class="line">        a[rt].lx = a[rt].rx = a[rt].mx = a[rt].sum = num[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(lson);</span><br><span class="line">    <span class="built_in">build</span>(rson);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询操作为本题目的核心</span></span><br><span class="line"><span class="comment">// 下面是返回区间最大子段和的代码</span></span><br><span class="line"><span class="function">node <span class="title">query_max</span><span class="params">(ll rt, ll l, ll r, ll L, ll R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &gt; R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">node</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="keyword">return</span> <span class="built_in">query_max</span>(lson, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="keyword">return</span> <span class="built_in">query_max</span>(rson, L, R);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        node x = <span class="built_in">query_max</span>(lson, L, mid);</span><br><span class="line">        node y = <span class="built_in">query_max</span>(rson, mid + <span class="number">1</span>, R);</span><br><span class="line">        node z;</span><br><span class="line">        z.sum = x.sum + y.sum;</span><br><span class="line">        z.lx = <span class="built_in">max</span>(x.lx, x.sum + y.lx);</span><br><span class="line">        z.rx = <span class="built_in">max</span>(y.rx, y.sum + x.rx);</span><br><span class="line">        z.mx = <span class="built_in">max</span>(<span class="built_in">max</span>(x.mx, y.mx), x.rx + y.lx);</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll rt, ll l, ll r, ll l1, ll r1, ll l2, ll r2)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 对应区间没有交集的情况</span></span><br><span class="line">    <span class="keyword">if</span>(r1 &lt; l2) &#123;</span><br><span class="line">        ll tmp = <span class="built_in">query_max</span>(rt, l, r, l1, r1).rx;</span><br><span class="line">        tmp += <span class="built_in">query_max</span>(rt, l, r, r1 + <span class="number">1</span>, l2 - <span class="number">1</span>).sum;</span><br><span class="line">        tmp += <span class="built_in">query_max</span>(rt, l, r, l2, r2).lx;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="built_in">query_max</span>(rt, l, r, l2, r1).mx;</span><br><span class="line">    <span class="comment">// 区间具有交集，注意这里的查询每一次都减去一个中间值，是因为会发生重复查询</span></span><br><span class="line">    <span class="keyword">if</span>(l1 &lt; l2) ans = <span class="built_in">max</span>(ans, <span class="built_in">query_max</span>(rt, l, r, l1, l2).rx + <span class="built_in">query_max</span>(rt, l, r, l2, r2).lx - num[l2]);</span><br><span class="line">    <span class="keyword">if</span>(r1 &lt; r2) ans = <span class="built_in">max</span>(ans, <span class="built_in">query_max</span>(rt, l, r, l1, r1).rx + <span class="built_in">query_max</span>(rt, l, r, r1, r2).lx - num[r1]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            ll l1, r1, l2, r2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l1, r1, l2, r2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3、区间最大子段和变形问题2"><a href="#3、区间最大子段和变形问题2" class="headerlink" title="3、区间最大子段和变形问题2"></a>3、区间最大子段和变形问题2</h2><font size=4>问题描述：给定一个序列$a_1,a_2, a_3,..a_n$，有$m$个区间，求出每一个对应区间的最大子段和，但是**区间中所有相同的数只能算一次。**</font><font size=5>例题：[SP1557](https://www.luogu.com.cn/problem/SP1557)</font><font size=4>**解决方案：** 这个问题虽然看起来和经典的最大子段和问题极其相似，但是如果按照经典的思路进行动态规划，区间合并，那么将会很难统计，因为所有相同的数字只能统计一次，会牵扯到判重的问题。区间判重是个相当不简单的任务，因此要另辟思路。</font><font size=4>**~~某位巨佬说过，在你感觉一切都没有思路的时候，排序一定可以帮到你。~~**</font><font size=4>因此，我们使用离线算法，==把所有的询问区间按照右边界大小从小到大排序==，然后线性扫描并且更新线段树。但是我们现在先不管这里询问的事情，暂且放下，现在最重要的是我们如何去判重，并且如何维护最大子段和？</font><font size=4>我们假定有下面这个序列：</font><font size=5>$$4, -2 ,-2,  3 ,-1, -4, 2, 2, -6$$</font><font size=4>规定：</font><ul><li><font size=4>$sum_i$：以位置$i$起始的子段和</font>。</li><li><font size=4>$hismax_i$：以位置$i$起始的最大子段和</font>。</li><li><font size=4>$tag_i$：以位置$i$起始的<strong>增加</strong>的子段和</font>。</li><li><font size=4>$hismaxtag_i$:以位置$i$起始的**增加**的最大子段和。</font><font size=4>注意：两个$tag$数组是为了后面的线段树的更新操作，是标记操作的基础。假设当前线性扫描到了$1$的位置。</font></li></ul><font size=4>==并且可以注意到在线性扫描的过程中，$sum_i$的值是一直在变化的，$hismax_i$就是$sum_i$出现过的最大的值，同理，$tag_i$的值是一直在变化的，$hismaxtag_i$就是$tag_i$出现过的最大的值。==</font><p><img src="https://img-blog.csdnimg.cn/001de609e4654f41a6e42ec687331013.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><div class="table-container"><table><thead><tr><th>$i$</th><th>$sum$</th><th>$hismax$</th><th>$tag$</th><th>$hismaxtag$</th></tr></thead><tbody><tr><td>$1$</td><td>$4$</td><td>$4$</td><td>$0$</td><td>$0$</td></tr><tr><td>$2$</td><td>$0$</td><td>$0$</td><td>$0$</td><td>$0$</td></tr><tr><td>$3$</td><td>$0$</td><td>$0$</td><td>$0$</td><td>$0$</td></tr><tr><td>$4$</td><td>$0$</td><td>$0$</td><td>$0$</td><td>$0$</td></tr></tbody></table></div><p><img src="https://img-blog.csdnimg.cn/b78eb6cbc883432b819e643e9782ce52.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><div class="table-container"><table><thead><tr><th>$i$</th><th>$sum$</th><th>$hismax$</th><th>$tag$</th><th>$hismaxtag$</th></tr></thead><tbody><tr><td>$1$</td><td>$4-2=2$</td><td>$4$</td><td>$-2$</td><td>$0$</td></tr><tr><td>$2$</td><td>$-2$</td><td>$-2$</td><td>$0$</td><td>$0$</td></tr><tr><td>$3$</td><td>$0$</td><td>$0$</td><td>$0$</td><td>$0$</td></tr><tr><td>$4$</td><td>$0$</td><td>$0$</td><td>$0$</td><td>$0$</td></tr></tbody></table></div><p><img src="https://img-blog.csdnimg.cn/33da36f24b934a25afeb5b9a69c38886.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>|  $i$ | $sum$  | $hismax$  | $tag$  | $hismaxtag$  |<br>|—-|—-|—-|—-|—-|<br>| $1$  | $4-2-2=0$ |  $4$ |  $-2-2=-4$ | $0$  |<br>|  $2$| $-2-2=-4$  |  $-2$ |  $-2$ |  $0$ |<br>|  $3$ |  $-2$ | $-2$  | $0$  | $0$ |<br>| $4$  |  $0$ |  $0$ | $0$  | $0$  |</p><p><img src="https://img-blog.csdnimg.cn/13141d7b58a74ae4984ad61580baf65e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>|  $i$ | $sum$  | $hismax$  | $tag$  | $hismaxtag$  |<br>|—-|—-|—-|—-|—-|<br>| $1$  | $4-2-2+3=3$ |  $4$ |  $-2-2+3=-1$ | $0$  |<br>|  $2$| $-2-2+3=-1$  |  $-1$ |  $-2+3=1$ |  $1$ |<br>|  $3$ |  $-2+3=1$ | $1$  | $3$  | $3$ |<br>| $4$  |  $3$ |  $3$ | $0$  | $0$  |</p><font size=4>到这里，应该很容易明白了吧！$tag_i$值就是从$i$后面开始加上去的一段和，$hismax_i$表示的就是从$i$开始的最大子段和，也是$sum_i$出现过的最大值，并且有：</font><font size=4>$$\begin{cases} hismax_i=hismaxtag_i+val_i\\sum_i=tag_i+val_i\end{cases}$$</font><font size=4>那么如何搞定重复统计的问题？**其实这个问题可以从贡献的角度去考虑，说到这里，其实有一个非常巧妙统计的技巧，我会在另一篇文章给出。** 从贡献的角度去考虑重复统计的问题，那么事情就变得简单很多了，举例说明。</font>![在这里插入图片描述](https://img-blog.csdnimg.cn/299fa215f28e4c9d84b863a1bfcda6f9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)<center>一个新序列</center>![在这里插入图片描述](https://img-blog.csdnimg.cn/32e17bf6f62f44c8913b4276d8b76ea7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center)<font size=4>图中的数字$2$有两个，一个在位置$3$， 一个在位置$7$，那么进行统计的时候，我们可以看到，对于区间$[1,3]$都是有一个$2$的，所以这个位置$7$的$2$对它们的$sum_i$贡献为零，然而它对区间$[4,7]$都是有贡献的，因此我们在统计的时候先预处理一下。</font><font size=4>规定：</font><ul><li><font size=4>$pre_i$：表示值等于$val_i$**最近**的一次扫描过的位置，比如上面的例子$pre_7=2$，$pre_8=4$。</font></li><li><font size=4>**当扫描到位置$i$的时候，我们便只需要更新区间$[pre_i+1,i]$就可以保证相同的数只被统计了一次！**</font></li></ul><hr><font size=4>线段树部分：（我们还是用第一个序列作为例子。）</font><font size=4>**1、定义线段树的树结点：**</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ll sum, hismax, tag, hismaxtag; <span class="comment">// 全部的值默认为 0</span></span><br><span class="line">&#125; tree[N&lt;&lt;<span class="number">2</span>];</span><br></pre></td></tr></table></figure><font size=4>线段树建成后，其中的叶子结点（红圈包围的）的$sum, hismax, hismaxtag, tag$与之前讨论的含义相同。而区间表示的含义则有些许不同：</font><ul><li><font size=4>$sum$：表示区间中最大的$sum_i$</font>。</li><li><font size=4>$hismax$：表示区间最大的$hismax_i$，实质为区间最大的子段和。</font>。</li><li><font size=4>$tag$：对于区间所有的$tag_i$都要增加的子段和</font>。</li><li><font size=4>$hismaxtag$：表示$tag$出现过的最大的值，也就是最大的**增加**子段和。</font></li></ul><p><img src="https://img-blog.csdnimg.cn/8054067739b0414a9dcb4eb549c416ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>现在询问两个区间：（**==已按照右端点大小排过序，排序的作用就是使得可以通过线性扫描一边更新，一边查询区间的的最大子段和==**）:$[1, 2]和[1, 5]$。</font><font size=4>**2、预处理$pre$数组**</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">        pre[i] = pos[val[i] + <span class="number">100000</span>]; <span class="comment">// 因为值是有负数的，为了保证位置大于等于0，所以做了偏移处理</span></span><br><span class="line">        pos[val[i] + <span class="number">100000</span>] = i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><font size=4>**3、更新线段树**</font><font size=4>线段树向上区间合并：</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(ll rt)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据上面的定义可以得到</span></span><br><span class="line">    tree[rt].sum = <span class="built_in">max</span>(tree[ls].sum, tree[rs].sum);</span><br><span class="line">    tree[rt].hismax = <span class="built_in">max</span>(tree[ls].hismax, tree[rs].hismax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>线段树向下压标记，进行”懒操作“，懒操作的意义在于，比如我要更新一段区间，但是里面所有的元素都要更新，那么我就设置一个$tag$来表示加上的子段，称作”增加“子段和。**注意向下懒操作更新数据的顺序不能反！**</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(ll rt)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 现在的子段和加上更新的最大”增加”子段和</span></span><br><span class="line">    tree[ls].hismax = <span class="built_in">max</span>(tree[ls].hismax, tree[ls].sum + tree[rt].hismaxtag);</span><br><span class="line">    tree[rs].hismax = <span class="built_in">max</span>(tree[rs].hismax, tree[rs].sum + tree[rt].hismaxtag);</span><br><span class="line">    <span class="comment">// 现在的”增加“子段和加上更新的最大”增加”子段和</span></span><br><span class="line">    tree[ls].hismaxtag = <span class="built_in">max</span>(tree[ls].hismaxtag, tree[ls].tag + tree[rt].hismaxtag);</span><br><span class="line">    tree[rs].hismaxtag = <span class="built_in">max</span>(tree[rs].hismaxtag, tree[rs].tag + tree[rt].hismaxtag);</span><br><span class="line">    <span class="comment">// 现在的子段和加上更新的“增加”子段和</span></span><br><span class="line"> <span class="comment">// 现在的”增加“子段和加上更新的“增加“子段和</span></span><br><span class="line">    tree[ls].sum += tree[rt].tag;</span><br><span class="line">    tree[rs].sum += tree[rt].tag;</span><br><span class="line">    tree[ls].tag += tree[rt].tag;</span><br><span class="line">    tree[rs].tag += tree[rt].tag;</span><br><span class="line">    <span class="comment">// 撤销标记</span></span><br><span class="line">    tree[rt].tag = tree[rt].hismaxtag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>更新函数：</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll rt, ll l, ll r, ll L, ll R, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123; <span class="comment">// 懒操作</span></span><br><span class="line">        tree[rt].tag += v;</span><br><span class="line">        tree[rt].sum += v;</span><br><span class="line">        tree[rt].hismaxtag = <span class="built_in">max</span>(tree[rt].hismaxtag, tree[rt].tag);</span><br><span class="line">        tree[rt].hismax = <span class="built_in">max</span>(tree[rt].hismax, tree[rt].sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="built_in">update</span>(lson, L, R, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="built_in">update</span>(rson, L, R, v);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">update</span>(lson, L, mid, v);</span><br><span class="line">        <span class="built_in">update</span>(rson, mid+<span class="number">1</span>, R, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>查询函数：</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll rt, ll l, ll r, ll L, ll R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[rt].hismax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(lson, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(rson, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(lson, L, mid), <span class="built_in">query</span>(rson, mid+<span class="number">1</span>, R));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=5>**图解过程**</font><font size=4>加入第一个元素$4$</font><script type="math/tex; mode=display">update(left=1,right=1)</script><p><img src="https://img-blog.csdnimg.cn/845e54ff5d674eb9ae75dbfc88375005.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>加入第二个元素$-2$</font><script type="math/tex; mode=display">update(left=1,right=2)</script><p><img src="https://img-blog.csdnimg.cn/f9f0beb42a744c93a1ee635739d749ba.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>查询区间$[1,2]，得到结果为$4$</font><script type="math/tex; mode=display">query(left=1, right=2)</script><p><img src="https://img-blog.csdnimg.cn/3b0362a4e4d2471aa5bd1b58cb5cb870.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>加入第三个元素$-2$</font><script type="math/tex; mode=display">update(left=3,right=3)</script><p><img src="https://img-blog.csdnimg.cn/a38ce5087a304e3b886f2a90dc3b8095.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>加入第四个元素$3$</font><script type="math/tex; mode=display">update(left=1,right=4)</script><p><img src="https://img-blog.csdnimg.cn/fb66a52e4e0a49938424513fab850be4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>加入第五个元素$-1$</font><script type="math/tex; mode=display">update(left=1,right=5)</script><p><img src="https://img-blog.csdnimg.cn/cb3896a4cf124988a8c3ed519dd5140b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>查询区间$[1,5]$，得到结果$5$</font><script type="math/tex; mode=display">query(left=1,right=5)</script><p><img src="https://img-blog.csdnimg.cn/dba0985102644e21b5f663a605e98d7c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=6>$\color{Green}{AC} \, \color{Red}{Code}$</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson ls, l, mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rs, mid + 1, r</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll N = <span class="number">1e5</span> + <span class="number">7</span>, inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">ll n, m, pre[N], ans[N], pos[N&lt;&lt;<span class="number">1</span>], val[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span> &#123;</span><br><span class="line">    ll l, r, id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Query&amp; b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; b.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ll sum, hismax, tag, hismaxtag;</span><br><span class="line">&#125; tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(ll rt)</span> </span>&#123;</span><br><span class="line">    tree[rt].sum = <span class="built_in">max</span>(tree[ls].sum, tree[rs].sum);</span><br><span class="line">    tree[rt].hismax = <span class="built_in">max</span>(tree[ls].hismax, tree[rs].hismax);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(ll rt)</span> </span>&#123;</span><br><span class="line">    tree[ls].hismax = <span class="built_in">max</span>(tree[ls].hismax, tree[ls].sum + tree[rt].hismaxtag);</span><br><span class="line">    tree[rs].hismax = <span class="built_in">max</span>(tree[rs].hismax, tree[rs].sum + tree[rt].hismaxtag);</span><br><span class="line">    tree[ls].hismaxtag = <span class="built_in">max</span>(tree[ls].hismaxtag, tree[ls].tag + tree[rt].hismaxtag);</span><br><span class="line">    tree[rs].hismaxtag = <span class="built_in">max</span>(tree[rs].hismaxtag, tree[rs].tag + tree[rt].hismaxtag);</span><br><span class="line">    tree[ls].sum += tree[rt].tag;</span><br><span class="line">    tree[rs].sum += tree[rt].tag;</span><br><span class="line">    tree[ls].tag += tree[rt].tag;</span><br><span class="line">    tree[rs].tag += tree[rt].tag;</span><br><span class="line">    tree[rt].tag = tree[rt].hismaxtag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll rt, ll l, ll r, ll L, ll R, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        tree[rt].tag += v;</span><br><span class="line">        tree[rt].sum += v;</span><br><span class="line">        tree[rt].hismaxtag = <span class="built_in">max</span>(tree[rt].hismaxtag, tree[rt].tag);</span><br><span class="line">        tree[rt].hismax = <span class="built_in">max</span>(tree[rt].hismax, tree[rt].sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="built_in">update</span>(lson, L, R, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="built_in">update</span>(rson, L, R, v);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">update</span>(lson, L, mid, v);</span><br><span class="line">        <span class="built_in">update</span>(rson, mid+<span class="number">1</span>, R, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll rt, ll l, ll r, ll L, ll R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[rt].hismax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(lson, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(rson, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(lson, L, mid), <span class="built_in">query</span>(rson, mid+<span class="number">1</span>, R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">        pre[i] = pos[val[i] + <span class="number">100000</span>];</span><br><span class="line">        pos[val[i] + <span class="number">100000</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; q[i].l &gt;&gt; q[i].r;</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m);</span><br><span class="line">    ll cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, pre[i] + <span class="number">1</span>, i, val[i]);</span><br><span class="line">        <span class="keyword">while</span>(cnt &lt;= m &amp;&amp; q[cnt].r &lt;= i) &#123;</span><br><span class="line">            ans[q[cnt].id] = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, q[cnt].l, q[cnt].r);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><font size=5>**文章制作不易，转载请注明出处。**</font>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/25/hello-world/"/>
      <url>/2022/05/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
