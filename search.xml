<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线段树和子段和，一篇就够</title>
      <link href="/2022/05/26/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E5%AD%90%E6%AE%B5%E5%92%8C/"/>
      <url>/2022/05/26/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="1、经典的区间最大子段和问题"><a href="#1、经典的区间最大子段和问题" class="headerlink" title="1、经典的区间最大子段和问题"></a>1、经典的区间最大子段和问题</h2><font size=4>问题描述：给定一个序列$a_1,a_2, a_3,..a_n$，如何求出该序列的最大子段和？（询问的区间个数为$m$）</font><font size=4>解决方案：</font><font size=4> - **暴力统计**：对于每一个区间$[l,r]$，每一次选定一个子段的起点，然后枚举子段的长度，算法复杂度为$O(mn^2)$。</font><font size=4> - **动态规划**：我们一次性算出所有的区间的最大子段和，然后使用直接询问答案。我们规定：</font><font size=4> - $\color{Green}ls$: 表示区间紧靠左端点的子段的最大和</font> <font size=4>- $\color{Blue}rs$: 表示区间紧靠右端点的子段的最大和</font> <font size=4>- $\color{OrangeRed}ms$: 表示区间子段的最大和</font><font size=4> - $\color{Blue}s$：表示区间子段和。</font><font size=4>假设一个区间为$[l,r]$，我们将它一分为二，并且我们假设已经得到了左边区间和右边区间的各自的四样所有信息，那么我们如何求出这个区间的的四个信息呢？</font><font size=4></font><font size=4>显然有：</font><font size=5>$$s=s_l+s_r$$</font><p><img src="https://img-blog.csdnimg.cn/d184e410f63a4122af5aab42bd7a8327.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>求解$ls$，那么我们有两个选择，选择左边区间的$ls$，或者是把左边区间全部选了然后再选取右边区间的$ls$。因为子段必须保持连续性，所以这两个选择是最优的。</font><font size=5>$$ls=max(ls_l, s_l+ls_r)$$</font><p><img src="https://img-blog.csdnimg.cn/3dda0d5c84ee4dd582f00c98564c05ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>同样道理求解$rs$，那么我们有两个选择，选择右边区间的$rs$，或者是把右边区间全部选了然后再选取左边区间的$rs$。因为子段必须保持连续性，所以这两个选择是最优的。</font><font size=5>$$rs=max(rs_r, s_r+rs_l)$$</font><p><img src="https://img-blog.csdnimg.cn/d1b75e5cbbba4cafb6f466032783a6e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>求解$ms$，那么我们有两个选择，选择右边区间的$ms$，或者是左边区间的$ms$，或者是左边区间的$rs$和右边区间的$ls$的和，因为选择保证了连续子段的连续性，所以最优解一定在上面三种选择中。</font><font size=5>$$ms=max(ms_r, ms_r, rs_l+ls_r)$$</font><p><img src="https://img-blog.csdnimg.cn/bb23010aaa504cfc92fbcd568b483e48.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>到此，我们完成了区间合并的工作，那么我们就可以使用区间合并的方式进行动态规划。</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line">ll n, m, a[maxn], val[maxn], ql, qr;</span><br><span class="line">ll ls[maxn][maxn], ms[maxn][maxn], rs[maxn][maxn], s[maxn][maxn]; <span class="comment">// 使用区间作为下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; val[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ls[i][i] = ms[i][i] = rs[i][i] = s[i][i] = val[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> r = i + len - <span class="number">1</span>, l = i;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">            s[l][r] = s[l][mid] + s[mid+<span class="number">1</span>][r];</span><br><span class="line">            ls[l][r] = <span class="built_in">max</span>(ls[l][mid], ls[mid+<span class="number">1</span>][r] + s[l][mid]);</span><br><span class="line">            rs[l][r] = <span class="built_in">max</span>(rs[mid+<span class="number">1</span>][r], rs[l][mid] + s[mid+<span class="number">1</span>][r]);</span><br><span class="line">            ms[l][r] = <span class="built_in">max</span>(<span class="built_in">max</span>(ms[l][mid], ms[mid+<span class="number">1</span>][r]), ls[mid+<span class="number">1</span>][r] + rs[l][mid]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; ql &gt;&gt; qr;</span><br><span class="line">        cout &lt;&lt; ms[ql][qr] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4> 由上面的代码可知，合并的区间越来越大，第一轮合并的区间为$n$个，第二轮合并的区间为$\dfrac{n}{2}$个，第三轮合并的区间为$\dfrac{n}{4}$个，所以总的合并区间个数约为$2n$个，总的复杂度为：$O(n+m)$，非常优秀！</font><font size=4> - **线段树**：我们可以使用动态规划可以非常快速地一次性算出所有的区间的最大子段和，然后使用直接询问答案。但是如果操作带修改的序列时，又如何设计更好的算法？那么线段树就可以大显神通了！==如果你学过线段树，你就会发现这个问题真的是和线段树天生一对啊！区间合并，单点修改，优秀的$O(\log n)$的复杂度!==</font><font size=4>下面是推荐的练习的题目：[SP1716](https://www.luogu.com.cn/problem/SP1716) </font><font size=6>$\color{Green}{AC} \, \color{Red}{Code}$</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> <span class="comment">// 万能头文件</span></span></span><br><span class="line"><span class="comment">// 使用宏定义来写线段树，节省代码量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson lc, l, mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rc, mid + 1, r</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> ll inf = <span class="number">2e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123; ll ms, ls, rs, s;&#125; tr[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上更新的操作就是区间合并的操作，我们在这里加入动态规划的核心操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    tr[rt].s = tr[lc].s + tr[rc].s;</span><br><span class="line">    tr[rt].ls = <span class="built_in">max</span>(tr[lc].ls, tr[rc].ls + tr[lc].s);</span><br><span class="line">    tr[rt].rs = <span class="built_in">max</span>(tr[rc].rs, tr[lc].rs + tr[rc].s);</span><br><span class="line">    tr[rt].ms = <span class="built_in">max</span>(<span class="built_in">max</span>(tr[lc].ms, tr[rc].ms), tr[lc].rs + tr[rc].ls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;tr[rt].s);</span><br><span class="line">        tr[rt].ls = tr[rt].rs = tr[rt].ms = tr[rt].s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(lson);</span><br><span class="line">    <span class="built_in">build</span>(rson);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 单点修改，然后往上合并</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        tr[rt].s = tr[rt].ms = tr[rt].ls = tr[rt].rs = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) <span class="built_in">modify</span>(lson, pos, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(rson, pos, val);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的查询操作和动态规划是一个思路。</span></span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[rt];</span><br><span class="line">    node x, y, w;</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) w = <span class="built_in">query</span>(lson, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) w = <span class="built_in">query</span>(rson, L, R);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        x = <span class="built_in">query</span>(lson, L, mid);</span><br><span class="line">        y = <span class="built_in">query</span>(rson, mid + <span class="number">1</span>, R);</span><br><span class="line">        w.s = x.s + y.s;</span><br><span class="line">        w.ls = <span class="built_in">max</span>(x.ls, x.s + y.ls);</span><br><span class="line">        w.rs = <span class="built_in">max</span>(y.rs, y.s + x.rs);</span><br><span class="line">        w.ms = <span class="built_in">max</span>(<span class="built_in">max</span>(x.ms, y.ms), x.rs + y.ls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="keyword">if</span>(x) &#123;</span><br><span class="line">            node ans = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, y, z);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans.ms);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>复杂度分析：查询操作复杂度为$O(\log n)$， 修改的复杂度为$O(\log n)$，总的复杂度为$O(n+m\log n)$。下面所有的变形问题，我们都使用线段树解决。</font><hr><h2 id="2、区间最大子段和变形问题1"><a href="#2、区间最大子段和变形问题1" class="headerlink" title="2、区间最大子段和变形问题1"></a>2、区间最大子段和变形问题1</h2><font size=4>问题描述：给定一个序列$a_1,a_2, a_3,..a_n$，给定$m$个区间组合，对于每一个区间组合$[x_1,y_1], \, [x_2, y_2]$，问对于左端点在$[x_1,y_1]$并且右端点在$[x_2,y_2]$的所有区间的最大子段和。</font><font size=4>**解决方案**：其实就是经典最大子段和问题的一个小变形，我们可以把区间组合的两个区间进行分类讨论：</font><ul><li><font size=4>两个区间没有交集，那么这时候很好办，**==因为要满足子段的连续的特性，所以中间的一段是必须要选择的==**，因此最优解就是：</font></li></ul><font size=5>$$ms=sum(r_1, l_2)+rs_{l_1, r_1}+ls_{l_2, r_2}$$</font><p><img src="https://img-blog.csdnimg.cn/40771820f69f47bf8507a0ee3cb4f695.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li><font size=4>两个区间有交集，那么也可以分为三种情况：</font>  - <font size=4>子段只在区间$[l_2,r_1]$中，此时的最大值为$ms_1=ms_{l_2,r_1}$</font>  - <font size=4>子段不只是在区间$[l_2,r_1]$中，**==为了满足连续性，所以必定是一头选左最大子段和，一头选右最大子段和==**：</font>      - <font size=4>第一种情况$ms_2=ls_{l_1,l_2}+rs_{l_2+1, r_2}$</font>      - <font size=4>第二种情况$ms_3=ls_{l_1,r_1}+rs_{r_1+1, r_2}$</font></li></ul><p><img src="https://img-blog.csdnimg.cn/84b922ecad344d04b370a22c852ebcff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><center size=4>第一种情况</center><p><img src="https://img-blog.csdnimg.cn/8ff1c454614a4a2aa42739540385d50f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><center size=4>第二种情况</center><font size=4>因此有最后的答案为：</font><font size=5>$$ms=max(ms_1,ms_2,ms_3)$$</font><font size=4>这也恰好对应了线段树的查找答案的方法！</font><font size=5>例题：[SP2916](https://www.luogu.com.cn/problem/SP2916) </font><font size=6>$\color{Green}{AC} \, \color{Red}{Code}$</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson ls, l, mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rs, mid + 1, r</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll N = maxn * <span class="number">4</span>;</span><br><span class="line">ll n, m, t, num[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    ll sum, lx, rx, mx;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(ll _s, ll _l, ll _r, ll _m):</span><br><span class="line">            <span class="built_in">sum</span>(_s), <span class="built_in">lx</span>(_l), <span class="built_in">rx</span>(_r), <span class="built_in">mx</span>(_m)&#123;&#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间合并操作，和经典问题是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(ll rt)</span> </span>&#123;</span><br><span class="line">    a[rt].sum = a[ls].sum + a[rs].sum;</span><br><span class="line">    a[rt].lx = <span class="built_in">max</span>(a[ls].lx, a[ls].sum + a[rs].lx);</span><br><span class="line">    a[rt].rx = <span class="built_in">max</span>(a[rs].rx, a[rs].sum + a[ls].rx);</span><br><span class="line">    a[rt].mx = <span class="built_in">max</span>(<span class="built_in">max</span>(a[ls].mx, a[rs].mx), a[ls].rx + a[rs].lx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll rt, ll l, ll r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;num[l]);</span><br><span class="line">        a[rt].lx = a[rt].rx = a[rt].mx = a[rt].sum = num[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(lson);</span><br><span class="line">    <span class="built_in">build</span>(rson);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询操作为本题目的核心</span></span><br><span class="line"><span class="comment">// 下面是返回区间最大子段和的代码</span></span><br><span class="line"><span class="function">node <span class="title">query_max</span><span class="params">(ll rt, ll l, ll r, ll L, ll R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &gt; R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">node</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="keyword">return</span> <span class="built_in">query_max</span>(lson, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="keyword">return</span> <span class="built_in">query_max</span>(rson, L, R);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        node x = <span class="built_in">query_max</span>(lson, L, mid);</span><br><span class="line">        node y = <span class="built_in">query_max</span>(rson, mid + <span class="number">1</span>, R);</span><br><span class="line">        node z;</span><br><span class="line">        z.sum = x.sum + y.sum;</span><br><span class="line">        z.lx = <span class="built_in">max</span>(x.lx, x.sum + y.lx);</span><br><span class="line">        z.rx = <span class="built_in">max</span>(y.rx, y.sum + x.rx);</span><br><span class="line">        z.mx = <span class="built_in">max</span>(<span class="built_in">max</span>(x.mx, y.mx), x.rx + y.lx);</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll rt, ll l, ll r, ll l1, ll r1, ll l2, ll r2)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 对应区间没有交集的情况</span></span><br><span class="line">    <span class="keyword">if</span>(r1 &lt; l2) &#123;</span><br><span class="line">        ll tmp = <span class="built_in">query_max</span>(rt, l, r, l1, r1).rx;</span><br><span class="line">        tmp += <span class="built_in">query_max</span>(rt, l, r, r1 + <span class="number">1</span>, l2 - <span class="number">1</span>).sum;</span><br><span class="line">        tmp += <span class="built_in">query_max</span>(rt, l, r, l2, r2).lx;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="built_in">query_max</span>(rt, l, r, l2, r1).mx;</span><br><span class="line">    <span class="comment">// 区间具有交集，注意这里的查询每一次都减去一个中间值，是因为会发生重复查询</span></span><br><span class="line">    <span class="keyword">if</span>(l1 &lt; l2) ans = <span class="built_in">max</span>(ans, <span class="built_in">query_max</span>(rt, l, r, l1, l2).rx + <span class="built_in">query_max</span>(rt, l, r, l2, r2).lx - num[l2]);</span><br><span class="line">    <span class="keyword">if</span>(r1 &lt; r2) ans = <span class="built_in">max</span>(ans, <span class="built_in">query_max</span>(rt, l, r, l1, r1).rx + <span class="built_in">query_max</span>(rt, l, r, r1, r2).lx - num[r1]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            ll l1, r1, l2, r2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l1, r1, l2, r2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3、区间最大子段和变形问题2"><a href="#3、区间最大子段和变形问题2" class="headerlink" title="3、区间最大子段和变形问题2"></a>3、区间最大子段和变形问题2</h2><font size=4>问题描述：给定一个序列$a_1,a_2, a_3,..a_n$，有$m$个区间，求出每一个对应区间的最大子段和，但是**区间中所有相同的数只能算一次。**</font><font size=5>例题：[SP1557](https://www.luogu.com.cn/problem/SP1557)</font><font size=4>**解决方案：** 这个问题虽然看起来和经典的最大子段和问题极其相似，但是如果按照经典的思路进行动态规划，区间合并，那么将会很难统计，因为所有相同的数字只能统计一次，会牵扯到判重的问题。区间判重是个相当不简单的任务，因此要另辟思路。</font><font size=4>**~~某位巨佬说过，在你感觉一切都没有思路的时候，排序一定可以帮到你。~~**</font><font size=4>因此，我们使用离线算法，==把所有的询问区间按照右边界大小从小到大排序==，然后线性扫描并且更新线段树。但是我们现在先不管这里询问的事情，暂且放下，现在最重要的是我们如何去判重，并且如何维护最大子段和？</font><font size=4>我们假定有下面这个序列：</font><font size=5>$$4, -2 ,-2,  3 ,-1, -4, 2, 2, -6$$</font><font size=4>规定：</font><ul><li><font size=4>$sum_i$：以位置$i$起始的子段和</font>。</li><li><font size=4>$hismax_i$：以位置$i$起始的最大子段和</font>。</li><li><font size=4>$tag_i$：以位置$i$起始的<strong>增加</strong>的子段和</font>。</li><li><font size=4>$hismaxtag_i$:以位置$i$起始的**增加**的最大子段和。</font><font size=4>注意：两个$tag$数组是为了后面的线段树的更新操作，是标记操作的基础。假设当前线性扫描到了$1$的位置。</font></li></ul><font size=4>==并且可以注意到在线性扫描的过程中，$sum_i$的值是一直在变化的，$hismax_i$就是$sum_i$出现过的最大的值，同理，$tag_i$的值是一直在变化的，$hismaxtag_i$就是$tag_i$出现过的最大的值。==</font><p><img src="https://img-blog.csdnimg.cn/001de609e4654f41a6e42ec687331013.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><div class="table-container"><table><thead><tr><th>$i$</th><th>$sum$</th><th>$hismax$</th><th>$tag$</th><th>$hismaxtag$</th></tr></thead><tbody><tr><td>$1$</td><td>$4$</td><td>$4$</td><td>$0$</td><td>$0$</td></tr><tr><td>$2$</td><td>$0$</td><td>$0$</td><td>$0$</td><td>$0$</td></tr><tr><td>$3$</td><td>$0$</td><td>$0$</td><td>$0$</td><td>$0$</td></tr><tr><td>$4$</td><td>$0$</td><td>$0$</td><td>$0$</td><td>$0$</td></tr></tbody></table></div><p><img src="https://img-blog.csdnimg.cn/b78eb6cbc883432b819e643e9782ce52.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><div class="table-container"><table><thead><tr><th>$i$</th><th>$sum$</th><th>$hismax$</th><th>$tag$</th><th>$hismaxtag$</th></tr></thead><tbody><tr><td>$1$</td><td>$4-2=2$</td><td>$4$</td><td>$-2$</td><td>$0$</td></tr><tr><td>$2$</td><td>$-2$</td><td>$-2$</td><td>$0$</td><td>$0$</td></tr><tr><td>$3$</td><td>$0$</td><td>$0$</td><td>$0$</td><td>$0$</td></tr><tr><td>$4$</td><td>$0$</td><td>$0$</td><td>$0$</td><td>$0$</td></tr></tbody></table></div><p><img src="https://img-blog.csdnimg.cn/33da36f24b934a25afeb5b9a69c38886.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>|  $i$ | $sum$  | $hismax$  | $tag$  | $hismaxtag$  |<br>|—-|—-|—-|—-|—-|<br>| $1$  | $4-2-2=0$ |  $4$ |  $-2-2=-4$ | $0$  |<br>|  $2$| $-2-2=-4$  |  $-2$ |  $-2$ |  $0$ |<br>|  $3$ |  $-2$ | $-2$  | $0$  | $0$ |<br>| $4$  |  $0$ |  $0$ | $0$  | $0$  |</p><p><img src="https://img-blog.csdnimg.cn/13141d7b58a74ae4984ad61580baf65e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>|  $i$ | $sum$  | $hismax$  | $tag$  | $hismaxtag$  |<br>|—-|—-|—-|—-|—-|<br>| $1$  | $4-2-2+3=3$ |  $4$ |  $-2-2+3=-1$ | $0$  |<br>|  $2$| $-2-2+3=-1$  |  $-1$ |  $-2+3=1$ |  $1$ |<br>|  $3$ |  $-2+3=1$ | $1$  | $3$  | $3$ |<br>| $4$  |  $3$ |  $3$ | $0$  | $0$  |</p><font size=4>到这里，应该很容易明白了吧！$tag_i$值就是从$i$后面开始加上去的一段和，$hismax_i$表示的就是从$i$开始的最大子段和，也是$sum_i$出现过的最大值，并且有：</font><font size=4>$$\begin{cases} hismax_i=hismaxtag_i+val_i\\sum_i=tag_i+val_i\end{cases}$$</font><font size=4>那么如何搞定重复统计的问题？**其实这个问题可以从贡献的角度去考虑，说到这里，其实有一个非常巧妙统计的技巧，我会在另一篇文章给出。** 从贡献的角度去考虑重复统计的问题，那么事情就变得简单很多了，举例说明。</font>![在这里插入图片描述](https://img-blog.csdnimg.cn/299fa215f28e4c9d84b863a1bfcda6f9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)<center>一个新序列</center>![在这里插入图片描述](https://img-blog.csdnimg.cn/32e17bf6f62f44c8913b4276d8b76ea7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center)<font size=4>图中的数字$2$有两个，一个在位置$3$， 一个在位置$7$，那么进行统计的时候，我们可以看到，对于区间$[1,3]$都是有一个$2$的，所以这个位置$7$的$2$对它们的$sum_i$贡献为零，然而它对区间$[4,7]$都是有贡献的，因此我们在统计的时候先预处理一下。</font><font size=4>规定：</font><ul><li><font size=4>$pre_i$：表示值等于$val_i$**最近**的一次扫描过的位置，比如上面的例子$pre_7=2$，$pre_8=4$。</font></li><li><font size=4>**当扫描到位置$i$的时候，我们便只需要更新区间$[pre_i+1,i]$就可以保证相同的数只被统计了一次！**</font></li></ul><hr><font size=4>线段树部分：（我们还是用第一个序列作为例子。）</font><font size=4>**1、定义线段树的树结点：**</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ll sum, hismax, tag, hismaxtag; <span class="comment">// 全部的值默认为 0</span></span><br><span class="line">&#125; tree[N&lt;&lt;<span class="number">2</span>];</span><br></pre></td></tr></table></figure><font size=4>线段树建成后，其中的叶子结点（红圈包围的）的$sum, hismax, hismaxtag, tag$与之前讨论的含义相同。而区间表示的含义则有些许不同：</font><ul><li><font size=4>$sum$：表示区间中最大的$sum_i$</font>。</li><li><font size=4>$hismax$：表示区间最大的$hismax_i$，实质为区间最大的子段和。</font>。</li><li><font size=4>$tag$：对于区间所有的$tag_i$都要增加的子段和</font>。</li><li><font size=4>$hismaxtag$：表示$tag$出现过的最大的值，也就是最大的**增加**子段和。</font></li></ul><p><img src="https://img-blog.csdnimg.cn/8054067739b0414a9dcb4eb549c416ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>现在询问两个区间：（**==已按照右端点大小排过序，排序的作用就是使得可以通过线性扫描一边更新，一边查询区间的的最大子段和==**）:$[1, 2]和[1, 5]$。</font><font size=4>**2、预处理$pre$数组**</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">        pre[i] = pos[val[i] + <span class="number">100000</span>]; <span class="comment">// 因为值是有负数的，为了保证位置大于等于0，所以做了偏移处理</span></span><br><span class="line">        pos[val[i] + <span class="number">100000</span>] = i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><font size=4>**3、更新线段树**</font><font size=4>线段树向上区间合并：</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(ll rt)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据上面的定义可以得到</span></span><br><span class="line">    tree[rt].sum = <span class="built_in">max</span>(tree[ls].sum, tree[rs].sum);</span><br><span class="line">    tree[rt].hismax = <span class="built_in">max</span>(tree[ls].hismax, tree[rs].hismax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>线段树向下压标记，进行”懒操作“，懒操作的意义在于，比如我要更新一段区间，但是里面所有的元素都要更新，那么我就设置一个$tag$来表示加上的子段，称作”增加“子段和。**注意向下懒操作更新数据的顺序不能反！**</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(ll rt)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 现在的子段和加上更新的最大”增加”子段和</span></span><br><span class="line">    tree[ls].hismax = <span class="built_in">max</span>(tree[ls].hismax, tree[ls].sum + tree[rt].hismaxtag);</span><br><span class="line">    tree[rs].hismax = <span class="built_in">max</span>(tree[rs].hismax, tree[rs].sum + tree[rt].hismaxtag);</span><br><span class="line">    <span class="comment">// 现在的”增加“子段和加上更新的最大”增加”子段和</span></span><br><span class="line">    tree[ls].hismaxtag = <span class="built_in">max</span>(tree[ls].hismaxtag, tree[ls].tag + tree[rt].hismaxtag);</span><br><span class="line">    tree[rs].hismaxtag = <span class="built_in">max</span>(tree[rs].hismaxtag, tree[rs].tag + tree[rt].hismaxtag);</span><br><span class="line">    <span class="comment">// 现在的子段和加上更新的“增加”子段和</span></span><br><span class="line"> <span class="comment">// 现在的”增加“子段和加上更新的“增加“子段和</span></span><br><span class="line">    tree[ls].sum += tree[rt].tag;</span><br><span class="line">    tree[rs].sum += tree[rt].tag;</span><br><span class="line">    tree[ls].tag += tree[rt].tag;</span><br><span class="line">    tree[rs].tag += tree[rt].tag;</span><br><span class="line">    <span class="comment">// 撤销标记</span></span><br><span class="line">    tree[rt].tag = tree[rt].hismaxtag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>更新函数：</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll rt, ll l, ll r, ll L, ll R, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123; <span class="comment">// 懒操作</span></span><br><span class="line">        tree[rt].tag += v;</span><br><span class="line">        tree[rt].sum += v;</span><br><span class="line">        tree[rt].hismaxtag = <span class="built_in">max</span>(tree[rt].hismaxtag, tree[rt].tag);</span><br><span class="line">        tree[rt].hismax = <span class="built_in">max</span>(tree[rt].hismax, tree[rt].sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="built_in">update</span>(lson, L, R, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="built_in">update</span>(rson, L, R, v);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">update</span>(lson, L, mid, v);</span><br><span class="line">        <span class="built_in">update</span>(rson, mid+<span class="number">1</span>, R, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=4>查询函数：</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll rt, ll l, ll r, ll L, ll R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[rt].hismax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(lson, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(rson, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(lson, L, mid), <span class="built_in">query</span>(rson, mid+<span class="number">1</span>, R));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font size=5>**图解过程**</font><font size=4>加入第一个元素$4$</font><script type="math/tex; mode=display">update(left=1,right=1)</script><p><img src="https://img-blog.csdnimg.cn/845e54ff5d674eb9ae75dbfc88375005.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>加入第二个元素$-2$</font><script type="math/tex; mode=display">update(left=1,right=2)</script><p><img src="https://img-blog.csdnimg.cn/f9f0beb42a744c93a1ee635739d749ba.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>查询区间$[1,2]，得到结果为$4$</font><script type="math/tex; mode=display">query(left=1, right=2)</script><p><img src="https://img-blog.csdnimg.cn/3b0362a4e4d2471aa5bd1b58cb5cb870.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>加入第三个元素$-2$</font><script type="math/tex; mode=display">update(left=3,right=3)</script><p><img src="https://img-blog.csdnimg.cn/a38ce5087a304e3b886f2a90dc3b8095.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>加入第四个元素$3$</font><script type="math/tex; mode=display">update(left=1,right=4)</script><p><img src="https://img-blog.csdnimg.cn/fb66a52e4e0a49938424513fab850be4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>加入第五个元素$-1$</font><script type="math/tex; mode=display">update(left=1,right=5)</script><p><img src="https://img-blog.csdnimg.cn/cb3896a4cf124988a8c3ed519dd5140b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=4>查询区间$[1,5]$，得到结果$5$</font><script type="math/tex; mode=display">query(left=1,right=5)</script><p><img src="https://img-blog.csdnimg.cn/dba0985102644e21b5f663a605e98d7c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX-Wwj-WPr-eIsQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><font size=6>$\color{Green}{AC} \, \color{Red}{Code}$</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson ls, l, mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson rs, mid + 1, r</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll N = <span class="number">1e5</span> + <span class="number">7</span>, inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">ll n, m, pre[N], ans[N], pos[N&lt;&lt;<span class="number">1</span>], val[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span> &#123;</span><br><span class="line">    ll l, r, id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Query&amp; b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; b.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ll sum, hismax, tag, hismaxtag;</span><br><span class="line">&#125; tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(ll rt)</span> </span>&#123;</span><br><span class="line">    tree[rt].sum = <span class="built_in">max</span>(tree[ls].sum, tree[rs].sum);</span><br><span class="line">    tree[rt].hismax = <span class="built_in">max</span>(tree[ls].hismax, tree[rs].hismax);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(ll rt)</span> </span>&#123;</span><br><span class="line">    tree[ls].hismax = <span class="built_in">max</span>(tree[ls].hismax, tree[ls].sum + tree[rt].hismaxtag);</span><br><span class="line">    tree[rs].hismax = <span class="built_in">max</span>(tree[rs].hismax, tree[rs].sum + tree[rt].hismaxtag);</span><br><span class="line">    tree[ls].hismaxtag = <span class="built_in">max</span>(tree[ls].hismaxtag, tree[ls].tag + tree[rt].hismaxtag);</span><br><span class="line">    tree[rs].hismaxtag = <span class="built_in">max</span>(tree[rs].hismaxtag, tree[rs].tag + tree[rt].hismaxtag);</span><br><span class="line">    tree[ls].sum += tree[rt].tag;</span><br><span class="line">    tree[rs].sum += tree[rt].tag;</span><br><span class="line">    tree[ls].tag += tree[rt].tag;</span><br><span class="line">    tree[rs].tag += tree[rt].tag;</span><br><span class="line">    tree[rt].tag = tree[rt].hismaxtag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll rt, ll l, ll r, ll L, ll R, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        tree[rt].tag += v;</span><br><span class="line">        tree[rt].sum += v;</span><br><span class="line">        tree[rt].hismaxtag = <span class="built_in">max</span>(tree[rt].hismaxtag, tree[rt].tag);</span><br><span class="line">        tree[rt].hismax = <span class="built_in">max</span>(tree[rt].hismax, tree[rt].sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="built_in">update</span>(lson, L, R, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="built_in">update</span>(rson, L, R, v);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">update</span>(lson, L, mid, v);</span><br><span class="line">        <span class="built_in">update</span>(rson, mid+<span class="number">1</span>, R, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll rt, ll l, ll r, ll L, ll R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[rt].hismax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(lson, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(rson, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(lson, L, mid), <span class="built_in">query</span>(rson, mid+<span class="number">1</span>, R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">        pre[i] = pos[val[i] + <span class="number">100000</span>];</span><br><span class="line">        pos[val[i] + <span class="number">100000</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; q[i].l &gt;&gt; q[i].r;</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m);</span><br><span class="line">    ll cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, pre[i] + <span class="number">1</span>, i, val[i]);</span><br><span class="line">        <span class="keyword">while</span>(cnt &lt;= m &amp;&amp; q[cnt].r &lt;= i) &#123;</span><br><span class="line">            ans[q[cnt].id] = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, q[cnt].l, q[cnt].r);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><font size=5>**文章制作不易，转载请注明出处。**</font>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/25/hello-world/"/>
      <url>/2022/05/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
